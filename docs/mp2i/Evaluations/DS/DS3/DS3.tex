\PassOptionsToPackage{dvipsnames,table}{xcolor}
\documentclass[11pt,a4paper]{article}

\usepackage{DS}

\begin{document}
\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/Macros.tex}}
\ModeExercice
\DS{MP2I}{3}{Décembre 2023}

\alertbox{\danger}{Consignes}{
	\begin{itemize}
		\item[\textbullet] Les programmes demandés doivent être écrits en C et on suppose que les librairies standards usuelles ({\tt <stdio.h>}, {\tt <stdlib.h>}, {\tt <stdbool.h>}) sont déjà importées.
		\item[\textbullet] On pourra toujours librement utiliser une fonction demandée à une question précédente même si cette question n'a pas été traitée.
		\item[\textbullet] Veillez à présenter vos idées et vos réponses partielles même si vous ne trouvez pas la solution complète à une question.
		\item[\textbullet] La clarté et la lisibilité de la rédaction et des programmes sont des éléments de notation.
	\end{itemize}
}


\begin{Exercise}[title={Algorithme du drapeau hollandais}]
    \begin{quote}
    \og{} \textit{Le problème du drapeau hollandais est un problème de programmation, présenté par Edsger Dijkstra, qui consiste à réorganiser une collection d'éléments identifiés par leur couleur, sachant que seules trois couleurs sont présentes (par exemple, rouge, blanc, bleu, dans le cas du drapeau des Pays-Bas).
    Étant donné un nombre quelconque de balles rouges, blanches et bleues alignées dans n'importe quel ordre, le problème est à les réarranger dans le bon ordre : les bleues d'abord, puis les blanches, puis les rouges.}\fg{}
    \begin{flushright}
        (Wikipedia)
    \end{flushright}
    \end{quote}
    On suppose déjà écrite la fonction {\tt echange} de prototype \mintinline{c}{void echange(int tab[], int i, int j)} qui échange les éléments d'indice {\tt i} et {\tt j} dans le tableau {\tt tab} et on considère dans la suite que cet échange s'effectue en temps constant. On donne ci-dessous une implémentation de  l'algorithme du drapeau hollandais en langage C permettant de réarranger les éléments d'un tableau ne contenant \textit{que} les trois valeurs entières 1, 2 et 3  :
    \inputpartC{hollandais.c}{}{}{22}{44}
    \Question{Etude de l'algorithme du drapeau hollandais.}
    \subQuestion{Faire fonctionner cet algorithme sur le tableau {\tt tab = \{1, 3, 2, 2, 3, 1\}}, et donner le contenu de {\tt tab} ainsi que celui des variables {\tt i1}, {\tt i2} et {\tt i3} lors du déroulement de l'algorithme en recopiant et complétant le tableau suivant : \smallskip \\
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|l|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|}
        \cline{2-5}
        \multicolumn{1}{c|}{}& tab & i1 & i2 & i3 \\
        \hline
       Initialisation &  \{1, 3, 2, 2, 3, 1\} & 0 & 5 & 5 \\
       \hline
       Etape 1 & \dots & \dots & \dots & \dots\\
    \hline
        Etape 2 & \dots & \dots & \dots & \dots \\
        \hline
        Etape 3 & \dots & \dots & \dots & \dots \\
        \hline
        Etape 4 & \dots & \dots & \dots & \dots \\
        \hline
        Etape 5 & \dots & \dots & \dots & \dots \\
        \hline
    \end{tabular}\smallskip}
    \subQuestion{Prouver la terminaison de cet algorithme.}
    \subQuestion{Prouver la correction de cet algorithme. \\
    \aide \; \textit{Indication : on pourra noter $n$ la taille du tableau et  :
    \begin{itemize}
        \item $P_1$ la tranche du tableau {\tt tab} comprise entre les indices 0 et {\tt i1} (exclu)
        \item $P_2$ la portion du tableau {\tt tab} comprise entre les indices {\tt i2} et {\tt i3} (exclu)
        \item $P_3$ la portion du tableau {\tt tab} comprise entre les indices {\tt i3} et $n-1$ (exclu)
    \end{itemize}
    Et prouver l'invariant suivant : \og{} $P_1$ ne contient que des 1, $P_2$ que des 2 et $P_3$ que des 3 \fg{}.
    }}
    \subQuestion{Justifier brièvement que l'algorithme du drapeau hollandais a une complexité temporelle linéaire.}
    \Question{Comparaison avec le tri par insertion}
    \subQuestion{Rappeler (sans justification), la complexité de l'algorithme du tri par insertion.}
    \subQuestion{On a mesuré qu'en utilisant l'algorithme du tri par insertion un ordinateur trie une liste de dix million d'éléments en 5 secondes. Quel est le temps prévisible approximatif pour trier une liste contenant un milliard d'éléments ?}
    \subQuestion{On a mesuré qu'en utilisant l'algorithme du drapeau hollandais un ordinateur trie une liste de dix million d'éléments en 0.2 secondes. Quel est le temps prévisible approximatif pour un trier une liste contenant un milliard d'éléments ?}
    

\end{Exercise}

\begin{Exercise}[title={Représentation des ensembles d'entiers}]\\
    En OCaml, on représente une partie de $\N$ par la liste \textbf{triée}  de ses éléments. Par exemple l'ensemble $\{ 2, 9, 1, 6, 8 \}$ sera représenté par la liste {\tt [1; 2; 6; 8; 9]}. Le but de l'exercice est d'étudier deux méthodes permettant de calculer l'union de deux ensembles ainsi représentés. Dans l'étude de la complexité, on notera $n_1$ la longueur de la première liste et $n_2$ celle de la seconde.
    \Question{Union en ajoutant chaque élément successivement}
    \subQuestion{Ecrire une fonction {\tt ajoute int -> int list -> int list} qui prend en argument un entier {\tt n}, une liste triée {\tt l} et insère {\tt elt} dans {\tt l} si {\tt elt} n'y figure pas déjà et sinon ne fait rien. Par exemples :
    \begin{itemize}
        \item {\tt insere 3 [2; 6; 7]} donne {\tt [2; 3; 6; 7]},
        \item {\tt insere 4 [1; 4; 5]} donne {\tt [1; 4; 5]}.
    \end{itemize}
    \subQuestion{Ecrire une fonction {\tt union} qui calcule l'union de deux listes en insérant successivement chacun des éléments de la première liste dans la seconde à l'aide de la fonction écrite à la question précédente.}
    \subQuestion{Déterminer la complexité temporelle en fonction de $n_1$ et $n_2$ dans le pire des cas de cette fonction.}
     }
    \Question{Deuxième méthode}
    \subQuestion{Recopier et compléter la fonction ci-dessous (pointillés des lignes 3, 4 et 5) qui à l'aide d'une correspondance de motifs sur les deux listes calcule directement leur union :
    \inputpartOCaml{union.ml}{}{}{1}{5}
    }
    \subQuestion{Prouver que cette fonction termine.}
    \subQuestion{Donner sa complexité temporelle  en fonction de $n_1$ et $n_2$.}
\end{Exercise}


\begin{Exercise}[title={Evaluation d'un polynôme par la méthode de Horner}]\\
    En Ocaml, on représente un polynôme par la liste de ses coefficients (le coefficient de plus haut degré en premier). On suppose dans toute la suite de l'exercice qu'il s'agit de coefficients entiers. Par exemple le polynôme $x^2 - 11x + 30$ est représenté par la liste {\tt [1, -11, 30]}.
    D'autre part on donne la fonction {\tt puissance : int -> int -> int} ci-dessous qui prend en argument deux entiers naturels {\tt a} et {\tt n} et calcule {\tt a} puissance {\tt n}
    \inputpartOCaml{polynome.ml}{}{}{1}{3}
    \Question{Evaluation naïve}
    \subQuestion{Justifier rapidement qu'avec la fonction {\tt puissance}, le calcul de $a^n$ demande $n$ multiplications.\label{p}}
    \subQuestion{On donne ci-dessous la fonction {\tt naif} permettant de calculer un polynôme en {\tt x} en donnant la liste de ses coefficients {\tt lcoeff} : \label{naif}
    \inputpartOCaml{polynome.ml}{}{}{6}{10}
    La fonction {\tt naif} utilise la fonction {\tt puissance} donnée en début d'exercice.\\
    Justifier rapidement la terminaison de cette fonction.}
    \subQuestion{Prouver la correction de la fonction {\tt naif}.\\
    \aide; \textit{Indication : penser à utiliser une identité mathématique entre le polynôme à calculer et celui calculé par l'appel récursif}}
    \subQuestion{Déterminer la complexité la fonction {\tt naif}.\\
    \aide \; \textit{Indication : on pourra noter $C(n)$ le nombre de multiplications pour une liste de $n$ coefficients puis établir que $C(n) = C(n-1) + n$ (utiliser le résultat de la question \ref{p})} }
    \Question{Méthode de Horner}
    \subQuestion{Montrer que $\displaystyle{\sum_{k=0}^{n} a_kx^k} = a_0 + x\times(a_1 + x \times (\dots + a_n))$}
    \subQuestion{En déduire un algorithme récursif pour calculer la valeur d'un polynôme sans calculer expliciterment les puissances de la variable.}
    \subQuestion{Ecrire une implémentation en OCaml de cet algorithme.}
    \subQuestion{Justifier rapidement que cet algorithme a une complexité linéaire.}
    \Question{\textbf{Bonus} : Rappeler (sans justification) la complexité de l'algorithme d'exponentiation rapide. Quelle sera la complexité de la fonction de la question \ref{naif} si on utilise l'exponentiation rapide pour le calcul des puissances ?}
\end{Exercise} 

\end{document}