\PassOptionsToPackage{dvipsnames,table}{xcolor}
\documentclass[11pt,a4paper]{article}

\usepackage{DS}

\begin{document}

\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/Macros.tex}}
\ModeConcours
\DS{MP2I}{3}{Décembre 2025}

\setboolean{corrige}{true}

\newcommand{\maillon}[3]{
	\begin{tabular}{|p{0.2cm}|p{0.2cm}|}
		\hline
		\rnode{#2}{#1} & \rnode{#3}{\phantom{$e_0$}} \\
		\hline
	\end{tabular}
}

\alertbox{\danger}{Consignes}{
	\begin{itemize}
		\item[\textbullet] Les programmes demandés doivent être écrits en C ou en OCaml. Dans le cas du C, on suppose que les librairies standards usuelles ({\tt <stdio.h>}, {\tt <stdlib.h>}, {\tt <stdbool.h>}, {\tt <stdassert.h>}, \dots) sont déjà importées.
		\item[\textbullet] On pourra toujours librement utiliser une fonction demandée à une question précédente même si cette question n'a pas été traitée.
		\item[\textbullet] Veillez à présenter vos idées et vos réponses partielles même si vous ne trouvez pas la solution complète à une question.
		\item[\textbullet] La clarté et la lisibilité de la rédaction et des programmes sont des éléments de notation.
	\end{itemize}
}


\begin{Exercise}[title={Tris}] \\
	On rappelle ci-dessous en pseudo-langage, l'algorithme du tri par sélection (aussi appelé tri par recherche itérée du minimum)\\
	\begin{algorithm}[H]
		\DontPrintSemicolon
		\caption{Tri par sélection}
		\Entree{tableau $tab = \{t_0, \dots, t_{n-1}\}$ de $n$ élements}
		\Sortie{aucune, le tableau $tab$ est modifié et trié en place}
		\everypar={\footnotesize \textcolor{gray}{\nl}}
		\Pour{$i \leftarrow 0$ à $n-1$  }{
			$i_m \leftarrow$ indice du minimum du sous tableau $\{t_i, \dots t_{n-1}\}$\\
			échanger dans $t$ les éléments d'indice $i$ et $i_m$
		}
	\end{algorithm}
	\Question{En recopiant et complétant le tableau suivant. Donner l'état des variables de l'algorithme lorsqu'on utilise cet algorithme pour trier le tableau \texttt{\{2, -5, -4, 4, 1\}}\\
	\renewcommand{\arraystretch}{1.3}
	 \begin{tabular}{|l|p{1cm}|p{5cm}|}
        \cline{2-3}
        \multicolumn{1}{l|}{} &  $i_m$ & $tab$ \\
        \hline
        après un tour de boucle & \comp{{\tt 1}} &\comp{{\tt \{-5, 2, -4, 4, 1\}}}  \\
        \hline
        après deux tours de boucle & \comp{{\tt 2}} & \comp{{\tt \{-5, -4, 2, 4, 1\}}}  \\
		\hline
		après trois tours de boucle & \comp{{\tt 4}} &\comp{{\tt \{-5, -4, 1, 4, 2\}}} \\
		\hline
        après quatre tours de boucle & \comp{{\tt 4}} & \comp{{\tt \{-5, -4, 1, 2, 4\}}}  \\
		\hline
      \end{tabular}
	.} 
	\Question{Ecrire en langage C une fonction de signature \mintinline{c}{indice_min_depuis(int tab[], int n, int ind)} qui renvoie l'indice d'une occurrence du minimum du tableau {\tt tab} de taille {\tt n} à partir de l'indice {\tt ind} (inclus).}
	\corpartC{selection.c}{}{}{13}{27}
	\Question{En langage C, on suppose \textit{déjà écrite} une fonction de signature \mintinline{c}{void echange(int tab[], int i, int j)} qui échange les éléments situés aux indices {\tt i} et {\tt j} dans le tableau {\tt tab}. Ecrire une fonction de signature \mintinline{c}{tri_selection(int tab[], int n)} qui tri le tableau {\tt tab} de taille {\tt n} en utilisant l'algorithme du tri par sélection.}
	\corpartC{selection.c}{}{}{30}{38}
	\Question{Montrer que l'algorithme du tri par sélection a une complexité quadratique en fonction de la taille $n$ du tableau.}
	\tcor{La fonction de recherche du minimum a une complexité en $\mathcal{O}(n)$ car la boucle de recherche s'exécute au plus $n$ fois et elle ne contient que des opérations élémentaires. Le tri appelle $n$ fois la fonction de recherche du minimum et donc a une complexité en $n \mathcal{O}(n) = \mathcal{O}(n^2)$.} 
	\Question{On suppose qu'on a trié un tableau de taille \numprint{500000} en $1.2$ secondes avec l'algorithme du tri par sélection, donner une estimation du temps nécessaire pour trier un tableau contenant un million d'éléments.}
	\tcor{La taille du tableau est doublé et la complexité est quadratique donc le temps de calcul sera approximativement multiplié par 4, on doit donc s'attendre à un temps de calcul d'environ 4.8 secondes.}
	\Question{Ecrire en OCaml une fonction {\tt separe : int list -> int list* int list} qui prend en argument une liste d'entiers {\tt lst} et renvoie un couple de deux listes contenant chacune une moitié des éléments de {\tt lst} (a une unité près). Par exemple {\tt separe [2; 8; 1; 4; 5]} peut renvoyer le couple {\tt [2; 1; 5], [8; 4]}.}
	\corpartOCaml{tri_fusion.ml}{}{}{7}{11}
	\Question{Ecrire en OCaml une fonction {\tt fusion : int list -> int list -> int list} qui prend en argument deux listes d'entiers triées et renvoie la liste triée de leur fusion. Par exemple {\tt fusion [1; 2; 5] [4; 8]} renvoie la liste {\tt [1; 2; 4; 5; 8]}.}
	\corpartOCaml{tri_fusion.ml}{}{}{1}{5}
	\Question{On rappelle que l'algorithme du tri fusion est un algorithme de tri récursif qui consiste en séparer en deux la liste des éléments à trier, à trier récursivement chacune de ces listes puis à les fusionner. Déduire des questions précédentes une fonction {\tt tri\_fusion : int list -> int list} qui prend en argument une liste d'entiers et renvoie cette liste triée.}
	\corpartOCaml{tri_fusion.ml}{}{}{13}{20}
	\Question{On admet qu'il faut $n$ comparaisons pour  fusionner deux listes dont la somme des longueurs est $n$. On cherche à déterminer la complexité du tri fusion en \textit{nombre de comparaison effectuées} et on note $C(n)$ le nombre de comparaisons afin de trier une liste de longueur $n$. Déterminer $C(0), C(1)$ et justifier rapidement que $C(n) = 2C(\dfrac{n}{2}) + n$.}
	\Question{Déduire de la relation précédente que pour tout $i \in \N^*$, $C(n) = 2^i C(\dfrac{n}{2^i}) + in$ et en déduire la complexité du tri fusion en nombre de comparaisons.}
\end{Exercise}

\begin{Exercise}[title = {Liste chaînée circulaire}]\\
	Le langage utilisé dans cet exercice est le langage C. \smallskip\\
	On veut implémenter une structure de données de liste chainée circulaire avec un pointeur sur la queue telle que représentée ci-dessous :
	\begin{center}
		\begin{tabular}{ccllllc}
			                                           &                         &                         &                         &                         & \rnode{liste}{{\footnotesize queue}} & \\
			                                           &                         &                         &                         &                         &                                      & \\
			\rnode{head}{\raisebox{-2pt}{\phantom{Y}}} & \maillon{$e_0$}{v0}{p0} & \maillon{$e_1$}{v1}{p1} & \maillon{$e_2$}{v2}{p2} & \maillon{$e_3$}{v3}{p3} & \maillon{$e_4$}{v4}{p4}              & \\
		\end{tabular}\\
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p0}{v1}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p1}{v2}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p2}{v3}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p3}{v4}
		\ncline[nodesepB=0.25cm,nodesepA=0.05cm]{*->}{liste}{v4}
		\ncbar[nodesepB=0.2cm,nodesepA=-0.2cm,angleA=-90,angleB=-90]{*->}{p4}{v0}
	\end{center} \bigskip
	La queue pointe toujours vers \textit{le dernier élément inséré} ainsi, après l'ajout d'un nouvel élément $e_5$, la structure de données ci-dessus devient :
	\begin{center}
		\begin{tabular}{ccllllcl}
			                                           &                         &                         &                         &                         &                         & \hspace{-0.6cm}\rnode{liste}{{\footnotesize queue}} & \\
			                                           &                         &                         &                         &                         &                         &                                                       \\
			\rnode{head}{\raisebox{-2pt}{\phantom{Y}}} & \maillon{$e_0$}{v0}{p0} & \maillon{$e_1$}{v1}{p1} & \maillon{$e_2$}{v2}{p2} & \maillon{$e_3$}{v3}{p3} & \maillon{$e_4$}{v4}{p4} & \maillon{$e_5$}{v5}{p5}                               \\
		\end{tabular}\\
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p0}{v1}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p1}{v2}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p2}{v3}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p3}{v4}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p4}{v5}
		\ncline[nodesepB=0.25cm,nodesepA=0.05cm]{*->}{liste}{v5}
		\ncbar[nodesepB=0.2cm,nodesepA=-0.2cm,angleA=-90,angleB=-90]{*->}{p5}{v0}
	\end{center} \bigskip
	Lorsqu'on retire un élément de cette structure de données, on retire le maillon qui \textit{suit le pointeur de queue}. Par conséquent, si on retire un élément de la structure de donnée ci-dessus, c'est le maillon contenant $e_0$ qui est retiré et on obtient :
	\begin{center}
		\begin{tabular}{ccllllcl}
			                                           &  &                         &                         &                         &                         & \hspace{-0.6cm}\rnode{liste}{{\footnotesize queue}} & \\
			                                           &  &                         &                         &                         &                         &                                                       \\
			\rnode{head}{\raisebox{-2pt}{\phantom{Y}}} &  & \maillon{$e_1$}{v1}{p1} & \maillon{$e_2$}{v2}{p2} & \maillon{$e_3$}{v3}{p3} & \maillon{$e_4$}{v4}{p4} & \maillon{$e_5$}{v5}{p5}                               \\
		\end{tabular}\\
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p1}{v2}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p2}{v3}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p3}{v4}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p4}{v5}
		\ncline[nodesepB=0.25cm,nodesepA=0.05cm]{*->}{liste}{v5}
		\ncbar[nodesepB=0.2cm,nodesepA=-0.2cm,angleA=-90,angleB=-90]{*->}{p5}{v1}
	\end{center} \bigskip
	Afin d'implémenter cette structure de données, on propose d'utiliser les types suivants
	\inputpartC{file.c}{}{}{5}{11}
	La liste chainée circulaire vide est alors représentée par le pointeur {\sc null}.
	\Question{En partant d'une liste chainée circulaire initialement vide, donner les étapes de son évolution (en schématisant l'état de la liste), après les opérations suivantes  : \begin{enumerate}
			\item {\tt ajouter 12}
			\item {\tt ajouter  6}
			\item {\tt ajouter  7}
			\item {\tt retirer }
			\item {\tt ajouter 42}
			\item {\tt retirer}
		\end{enumerate}
		On précisera la valeur des entiers renvoyés par la fonction {\tt retirer}.
	}
	\tcor{
		\begin{enumerate}
			\item {\tt ajouter 12} : {\tt \underline{12}}
			\item {\tt ajouter  6} : {\tt 12} $\rightarrow$ {\tt \underline{6}}
			\item {\tt ajouter  7} : {\tt 12} $\rightarrow$ {\tt 6} $ \rightarrow$ {\tt \underline{7}}
			\item {\tt retirer } : {\tt 6} $\rightarrow$ {\tt \underline{7}}, l'opération renvoie 12
			\item {\tt ajouter 42}: {\tt 6} $\rightarrow$ {\tt 7} $\rightarrow${\tt \underline{42}}
			\item {\tt retirer} : {\tt 7} $\rightarrow${\tt \underline{42}}, l'opération renvoie 6
		\end{enumerate}
	}
	\Question{Ecrire la fonction {\tt ajouter} de signature \mintinline{c}{void ajouter(liste_circulaire *lc, int v)} qui modifie la liste circulaire donnée en argument en lui ajoutant un nouveau maillon contenant la valeur {\tt v}.\\
	{\small \aide \;} Indication : on fera attention à traiter le cas particulier d'une liste circulaire initialement vide.
	}
	\ifcorrige
	\corpartC{file.c}{}{}{18}{32}
	\fi
	\Question{Ecrire la fonction {\tt retirer} de signature \mintinline{c}{int retirer(liste_circulaire *lc)} qui prend en argument une liste circulaire \textit{supposée non vide} et renvoie la valeur du maillon situé après le pointeur de queue en le retirant de la liste circulaire.}
	\ifcorrige
	\corpartC{file.c}{}{}{43}{57}
	\fi
	\Question{Quelle structure de données connue a-t-on implémenté ici ? Justifier et proposer des noms plus appropriés pour les fonctions {\tt ajouter} et {\tt retirer}.}
	\tcor{Les premiers éléments ajoutés à la structure sont aussi les premiers à être retirés, il s'agit donc d'une struture de données de type {\sc fifo}, c'est à  dire une file. L'opération ajouter correspond à enfiler et l'opération retirer à défiler.}
	\Question{Ecrire une fonction {\tt longueur} de signature \mintinline{c}{int longueur(liste_circulaire lc)} qui renvoie le nombre d'éléments d'une liste chaînée circulaire.}
	\ifcorrige
	\corpartC{file.c}{}{}{59}{76}
	\fi
	\Question{Donner, en les justifiant, les complexités des opérations {\tt retirer}, {\tt ajouter} et {\tt longueur}.}
	\tcor{Retirer et ajouter sont en $O(1)$ car on ne fait que des opérations élémentaires et longueur est en $O(n)$ où $n$ est la longueur de la liste car celle ci doit être parcourue en entier (on détecte un retour vers le pointeur initial).}
\end{Exercise}


\begin{Exercise}[title={dépouillement d'un vote}]\\
	Le langage utilisé dans cet exercice est OCaml. On s'intéresse à la comptabilisation des résultats d'une élection. Chaque candidat  est désigné par un caractère ({\tt 'A', 'B', \dots}) et on suppose qu'on dispose des votes sous la forme d'une liste de caractère, par exemple la liste {\tt ['A'; 'C'; 'B'; 'B'; 'A'; 'A']} signifie qu'il y a eu 6 votants, le candidat {\tt 'A'} a obtenu 3 voix, le {\tt 'B'} deux voix et le {\tt 'C'} une voix. On souhaite dans un premier temps à partir de la liste des votes construire la liste des couples (candidat, nombre de votes), c'est à dire que si la liste des votes est {\tt ['A'; 'C'; 'B'; 'B'; 'A'; 'A']} alors on veut construire la liste {\tt [('A',3); ('C',1); ('B',2)]}.
	\Question{Ecrire une fonction {\tt appartient : char -> char list -> bool} qui prend en argument un caractère {\tt c} et une liste de caractères {\tt lst} et qui renvoie {\tt true} si et seulement si {\tt c} est dans {\tt lst}.}
	\corpartOCaml{election.ml}{}{}{1}{4}
	\Question{En déduire une fonction {\tt candidats : char list -> char list} qui prend en argument une liste {\tt votes} et renvoie cette liste sans aucun doublon, par exemple {\tt candidats ['A'; 'C'; 'B'; 'B'; 'A'; 'A']} renvoie la liste {\tt ['A', 'C', 'B']}.}
	\corpartOCaml{election.ml}{}{}{7}{10}
	\Question{Ecrire une fonction {\tt nb\_votes : char -> char list -> int} qui prend en argument un caractère {\tt c} et une liste de caractères {\tt votes} et renvoie le nombre d'apparition de {\tt c} dans {\tt votes}. Par exemple {\tt nb\_votes 'A' ['A'; 'C'; 'B'; 'B'; 'A'; 'A']} renvoie  {\tt 3}.}
	\corpartOCaml{election.ml}{}{}{13}{16}
	\Question{En déduire une fonction {\tt comptabilise : char list -> (char*int) list} qui répond au problème posé, c'est à dire qu'elle prend en argument une liste de caractères {\tt votes} et renvoie une liste de couples {\tt (char*int)} de chacun des caractères apparaissant dans {\tt votes} et de son nombre d'occurrences dans {\tt votes}.}
	\corpartOCaml{election.ml}{}{}{18}{20}
	\Question{On veut maintenant écrire une version de la fonction {\tt comptabilise} qui parcourt une seule fois la liste des votes. Pour cela on veut écrire une fonction {\tt ajoute : char -> char*int list -> char*int list} qui prend en argument un caractère {\tt un\_vote}, une liste de couples {\tt (char*int) list} qui représente un résultat partiel du dépouillement des votes et renvoie le nouveau décompte des voix après prise en compte de {\tt un\_vote} . Par exemple :
	\begin{itemize}
		\item {\tt ajoute 'B' [('A',2); ('C',1)]} renvoie {\tt [('A',2); ('C',1); ('B', 1)]} (premier vote obtenu par le candidat {\tt 'B'})
		\item {\tt ajoute 'C' [('A',2); ('C',1)]} renvoie {\tt [('A',2); ('C',2)]} (incrémente le nombre de vote du candidat {\tt 'C'})
	\end{itemize}. Ecrire la fonction {\tt ajoute}.}
	\corpartOCaml{election.ml}{}{}{22}{25}
	\Question{En déduire une nouvelle version de la fonction {\tt comptabilise} qui parcourt une seule fois la liste des votes.}
	\corpartOCaml{election.ml}{}{}{27}{30}
\end{Exercise}

\begin{Exercise}[title = {Représentation d'ensemble d'entiers}] \\
	En OCaml, on propose de représenter un ensemble d'entiers, par la liste \textit{triée} (dans l'ordre croissant) de ses éléments. Par exemple l'ensemble {\tt \{7; 2; 5; 3\}} sera représenté par la liste {\tt [2; 3; 5; 7]}. Par contre, les listes {\tt [2; 3; 3; 5; 7]} (élément en double) ou {\tt [2; 5; 3; 7]} (non triée) ne représentent pas correctement un ensemble.
	\Question{Ecrire une fonction \mintinline{ocaml}{est_ensemble: int list -> bool} qui renvoie {\tt true} lorsque la liste d'entier fournie en argument représente correctement un ensemble.}
	\corpartOCaml{ensemble.ml}{}{}{1}{5}
	\Question{Ecrire une fonction \mintinline{ocaml}{intersection : int list -> int list -> int list} qui prend en argument deux listes d'entiers (en supposant que ces deux listes représentent correctement des ensembles) et renvoie la liste d'entiers représentant l'union de ces deux listes. Par exemple {\tt intersection [2; 5; 7] [5; 6; 7; 10];;} renvoie {\tt [5; 7]}.}
	\corpartOCaml{ensemble.ml}{}{}{23}{29}
	\Question{Quelle serait la complexité d'une fonction \mintinline{ocaml}{appartient : int -> int list -> bool} qui teste si un entier appartient ou non à une liste d'entiers représentant correctement un ensemble ? (on ne demane pas d'écrire la fonction appartient mais simplement d'en justifier la complexité)}
	\tcor{La complexité serait linéaire car dans le pire des cas, on doit parcourir toute la liste afin de savoir si l'élément cherché s'y trouve ou non.}
	\NRet
	On souhaite maintenant de façon similaire représenté un ensemble d'entier en langage C par le tableau trié de ses éléments, cette structure de donnée est \textit{non mutable} c'est à dire que si on souhaite par exemple ajouter un élément à un ensemble alors on crée un nouvel ensemble.
	
	\Ret
	\Question{Proposer un type structuré {\tt ensemble} en C qui réalise cette représentation.}
	\Question{Ecrire la fonction de signature \mintinline{c}{bool appartient(ensemble ens, int elt)} qui renvoie {\tt true} si et seulement si {\tt elt} appartient à {\tt ens}. Cette fonction \textit{doit procéder} en parcourant un à un les éléments du tableau représentant l'ensemble. On donnera la complexité de cette fonction (aucune justification n'est demandée).}
	\Question{Donner en pseudo-langage un algorithme vu en cours et qui permettrait d'écrire une version de complexité linéarithmique de la fonction {\tt appartient} en s'appuyant sur le fait que les élements du tableau sont triés.}
\end{Exercise}
\end{document}