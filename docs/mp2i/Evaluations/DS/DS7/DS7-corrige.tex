\PassOptionsToPackage{dvipsnames,table}{xcolor}
\documentclass[11pt,a4paper]{article}

\usepackage{DS}

\begin{document}
\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/Macros.tex}}
\ModeConcours
\CB{MP2I}{Mai 2024}
\newcommand{\non}{\neg}
\newcommand{\et}{\wedge}
\newcommand{\ou}{\vee}
\newcommand{\imp}{\to}
\newcommand{\eq}{\leftrightarrow}
\setboolean{corrige}{true}

\newcommand{\maillon}[3]{
	\begin{tabular}{|p{0.2cm}|p{0.2cm}|}
		\hline
		\rnode{#2}{#1} & \rnode{#3}{\phantom{$e_0$}} \\
		\hline
	\end{tabular}
}

\alertbox{\danger}{Consignes}{
	\begin{itemize}
		\item[\textbullet] Les programmes demandés doivent être écrits en C ou en OCaml suivant l'exercice. Dans le cas du C, on suppose que les librairies standards usuelles ({\tt <stdio.h>}, {\tt <stdlib.h>}, {\tt <stdbool.h>}) sont déjà importées.
		\item[\textbullet] On pourra toujours librement utiliser une fonction demandée à une question précédente même si cette question n'a pas été traitée.
		\item[\textbullet] Veillez à présenter vos idées et vos réponses partielles même si vous ne trouvez pas la solution complète à une question.
		\item[\textbullet] La clarté et la lisibilité de la rédaction et des programmes sont des éléments de notation.
	\end{itemize}
}

\begin{Exercise}[title = {Base de données et {\sc sql}}, origin = {\bac \; {\sc capes nsi 2021}, épreuve 1} ]\\
On s'intéresse dans cette partie à un site Internet d'échange de supports de cours entre enseignants  de {\sc mp2i/mpi}. Chaque personne désirant proposer ou récupérer du contenu doit commencer par se créer un compte sur ce site et peut ensuite accéder à du contenu ou en proposer.

Ce site repose sur une base de données contenant en particulier une table, nommée {\tt ressources}. Elle possède un enregistrement par document téléversé sur le site. Ses attributs sont :
\begin{itemize}
	\item {\tt id}, un identifiant numérique, unique pour chaque ressource ;
	\item {\tt owner}, le pseudo de la personne ayant créé la ressource ;
	\item {\tt annee}, l'année de publication de la ressource ;
	\item {\tt titre}, une chaine de caractères décrivant la ressource ;
	\item {\tt type}, chaine de caractères pouvant être cours, ds, tp ou td.
\end{itemize}

Voici un extrait de cette table :

\medskip

\begin{center}
	\begin{tabular}{|l|l|c|c|r|}
		\hline
		{\tt id}       & {\tt owner}                          & {\tt annee}    & {\tt titre}                     & {\tt type}     \\
		\hline
		4        & dknuth                         & 2020     & Machine à décalage        & cours    \\
		13       & alovelace                      & 2022     & Intelligence artificielle & td       \\
		$\cdots$ & $\cdots$                       & $\cdots$ & $\cdots$                  & $\cdots$ \\
		\hline
	\end{tabular}
\end{center}


\Question{Écrire une requête SQL permettant de connaitre tous les titres des ressources déposées par \og{}{\tt jclarke}\fg{} classées par année de publication croissante.}
\ifcorrige
\begin{minted}{sql}
SELECT titre 
FROM ressources 
WHERE owner = "jclarke"
ORDER BY annee ASC;
\end{minted}
\fi
\Question{Écrire une requête SQL permettant de connaitre le nombre total de ressources de type cours présentes sur le site.}
\begin{minted}{sql}
SELECT COUNT(*)
FROM ressources
WHERE type = "cours";
\end{minted}
\Question{Que fait la requête suivante : ?
	      \begin{minted}{sql}
SELECT R.owner
FROM Ressources AS R
WHERE R.type = 'td'
GROUP BY R.owner
ORDER BY COUNT(*) DESC
LIMIT 3
\end{minted}
}
\tcor{Cette requête permet d'afficher les trois premiers propriétaires de ressources ayant posté le plus de ressources de type {\tt td}}
\end{Exercise}

\begin{Exercise}[title = {Logique et calcul des propositions}, origin = {\bac \; {\sc ccinp 2018 - mp}}]
	Vous avez été sélectionné(e) pour participer au jeu ``Cherchez les Clés du Paradis (CCP)".
	Le jeu se déroule en trois épreuves, au cours desquelles vous devez collecter des clés vertes.
	A l'issue de chacune d'entre elles, vous passez à l'épreuve suivante en cas de succès et êtes éliminé(e) en cas d'échec.\\

	\ExePart[name = {Première épreuve}]\\
	Jean-Pierre Pendule, le célèbre animateur, vous accueille pour la première épreuve.
	Il vous explique la règle du jeu.
	Devant vous, deux boîtes et sur chacune d'entre elles une inscription.
	Chacune des boîtes contient soit une clé verte, soit une clé rouge.
	Vous devez choisir l'une des boîtes~: si le résultat est une clé rouge, alors vous quittez le jeu, si c'est une clé verte vous êtes qualifié(e) pour l'épreuve suivante.

	Jean-Pierre Pendule dévoile les inscriptions sur chacune des boîtes et vous affirme qu'elles sont soit vraies toutes les deux, soit fausses toutes les deux~:
	\begin{itemize}
		\item sur la boîte $1$, il est écrit \og{}Une au moins des deux boîtes contient une clé verte\fg{};
		\item  sur la boîte $2$, il est écrit \og{}Il y a une clé rouge dans l'autre boîte\fg{}.
	\end{itemize}
	Dans toute cette partie, on note $P_i$ la proposition affirmant qu'il y a une clé verte dans la boîte $i$.
	\Question{Donner une formule de la logique des propositions représentant la phrase écrite sur la boîte 1.}
	\tcor{La formule logique associée à la phrase de la boîte 1 est $P_1 \ou P_2$}
	\Question{Donner de même une formule de la logique des propositions pour l'inscription de la boîte 2.}
	\tcor{La formule logique associée à la phrase de la boîte 2 est $\non P_1$}
	\Question{Donner une formule représentant l'affirmation de l'animateur. Simplifier cette formule de sorte à n'obtenir qu'une seule occurrence de chaque $P_i$.}
	\tcor{L'affirmation de l'animateur se traduit par \\ 
	$\begin{array}{lll}
		Q &= &((P_1 \ou P_2) \et \non P_1) \ou (\non(P_1 \ou P_2) \et \non \non P_1) \\
		Q 	& = & ((P_1 \et \non P_1) \ou P_2 \et \non P_1) \ou (\non P_1 \et \non P_2 \et P_1) \\
			& = & P_2 \et \non P_1
	\end{array}$
	}
	\Question{Quel choix devez-vous faire pour continuer le jeu à coup sûr~?}\\
	\tcor{D'après la question précédente, la clé verte se trouve dans la boîte 2, il faut donc choisir cette boîte.}

	\ExePart[name = {Deuxième épreuve}]\\
	Bravo, vous avez obtenu la première clé verte.
	Jean-Pierre Pendule vous félicite et vous annonce que cette première épreuve n'était qu'une mise en jambe.
	Avec les mêmes règles du jeu, l'animateur vous propose alors deux nouvelles boîtes portant les inscriptions suivantes~:
	\begin{itemize}
		\item sur la boîte $1$, il est écrit \og{}Il y a une clé rouge dans cette boîte, ou bien il y a une clé verte dans la boîte 2\fg{};
		\item  sur la boîte $2$, il est écrit \og{}Il y a une clé verte dans la boîte 1\fg{}.
	\end{itemize}
	\Question{Donner une formule de la logique des propositions pour chaque affirmation.}
	\tcor{
		L'affirmation de la boîte $1$ se traduit par $\non P_1 \ou P_2$ et celle de la boîte 2 par $P_1$
	}
	\Question{Sachant qu'encore une fois les deux affirmations sont soit vraies toutes les deux, soit fausses toutes les deux, donner le contenu de chaque boîte. En déduire votre choix pour remporter la deuxième clé verte.}\\
	\tcor{
	Cette fois l'affirmation de l'animateur se traduit par \\
	$\begin{array}{lll}
		R 	& = & ((\non P_1 \ou P_2) \et P_1) \ou (\non (\non P_1 \ou P_2) \et \non P_1)\\
			& = & (P_1 \et P_2) \ou (P_1 \et \non P_2 \et \non P_1) \\
			& = & P_1 \et P_2
	\end{array}$\\
	Les deux boîtes contiennent une clé verte, on peut donc choisir n'importe laquelle des deux.
	}


	\ExePart[name = {Troisième épreuve}]\\
	Le suspens est à son comble, vous voici arrivé(e) à la dernière épreuve.
	A votre grande surprise, Jean-Pierre Pendule vous dévoile une troisième boîte et vous explique les règles du jeu.
	Dans une des boîtes se cache la clé qui vous permet de remporter la victoire finale.
	Dans une autre boîte se cache une clé rouge qui vous fait tout perdre.
	La dernière boîte est vide.
	Encore une fois, chacune des boîtes porte une inscription~:
	\begin{itemize}
		\item sur la boîte $1$, il est écrit \og{}La boîte 3 est vide\fg{};
		\item  sur la boîte $2$, il est écrit \og{}La clé rouge est dans la boîte 1\fg{}~;
		\item  sur la boîte $3$, il est écrit \og{}Cette boîte est vide\fg{}.
	\end{itemize}
	L'animateur affirme que l'inscription portée sur la boîte contenant la clé verte est vraie, celle portée par la boîte contenant la clé rouge est fausse.
	L'inscription affichée sur la boîte vide est aussi vraie.
	\Question{Donner une formule de la logique des propositions pour chaque inscription.}
	\tcor{Pour $i \in \intN{1}{3}$, on note $Q_i$ la proposition \og{} la boîte $i$ contient la clé rouge \fg{}. Le fait que la boîte $i$ soit vide se traduit alors par $\non P_i \et \non Q_i$. Les inscriptions se traduisent alors par :
	\begin{itemize}
		\item boîte 1 : $\non P_3 \et \non Q_3$,
		\item boîte 2 : $Q_1$,
		\item boîte 3 : $\non P_3 \et \non Q_3$.
	\end{itemize}}
	\Question{Donner une formule de la logique des propositions synthétisant l'information que vous a apportée l'animateur.}
	\tcor{
		Une boîte ne pouvant contenir les deux clés, $P_i$ et $Q_i$ ne peuvent être vraies en même temps, c'est à dire : \\
		 $P_i \et Q_i \equiv \bot$ pour $i \in \intN{1}{3}$.\\
		 D'autre part, une  unique boîte contient la clé verte, donc : \\
		$(P_1 \et \non P_2 \et \non P_3) \ou (\non P_1 \et P_2 \et \non P_3)  \ou (\non P_1 \et \non P_2 \et P_3) \equiv \top $\\
		de la même une unique boîte contient la clé rouge,\\
		$(Q_1 \et \non Q_2 \et \non Q_3) \ou (\non Q_1 \et Q_2 \et \non Q_3)  \ou (\non Q_1 \et \non Q_2 \et Q_3) \equiv \top $. \\
		La fait qu'une unique boîte soit vide peut se traduire par : $\non P_i \et \non Q_i$ pour un unique $i \in \intN{1}{3}$.
	}
	\Question{En supposant que la clé verte est dans la boîte 2, montrer que l'on aboutit à une incohérence.}
	\tcor{
		Si on suppose que $P_2 \equiv \top$ (alors $Q_2 \equiv \bot$), l'affirmation de la boîte 2 est vraie, donc $Q_1 \equiv \top$ (et $P_1 \equiv \bot$). Cela impose que la boîte 3 soit vide. Par conséquent l'affirmation de la boîte 1 est fausse et celle de la boîte 3 est vraie. Ces deux informations étant identiques, on aboutit à une contradiction.
	}
	\Question{Donner alors la composition des trois boîtes.}
	\tcor{
		D'après la question précédente, la clé verte ne peut pas se trouver dans la boîte 2 , elle ne peut pas non plus être dans la boîte 3 (car sinon l'affirmation de cette boîte serait vraie et elle serait vide). La clé verte est donc dans la boîte 1 et donc la boîte 3 est vide et la clé rouge est dans la boîte 2.
	}

\end{Exercise}

\begin{Exercise}[title = {Traversée maximale d'une matrice carrée}]\\
	Les fonctions demandées dans cet exercice doivent être écrites en OCaml. On rappelle que qu'en OCaml, on peut convertir une liste en tableau à l'aide de {\tt Array.of\_list} par exemple {\tt Array.of\_list [6; 7; 42;]} renvoie {\tt [| 6; 7; 42; |]}\smallskip \\
	On considère une matrice à $n$ lignes et $n$ colonnes notée $M$ à coefficients dans $\N$, et dont le coefficient situé à la ligne $i$ et à la colonne $j$ avec $0 \leqslant i \leqslant n-1$ et  $0 \leqslant j \leqslant n-1$ sera noté $M_{i,j}$. On s'intéresse aux chemins depuis la première valeur en haut à gauche ($M_{0,0})$ jusqu'à la dernière en bas à droite ($M_{n-1,n-1}$) qui n'utilisent que les déplacements vers la droite ($\rightarrow$) ou vers le bas ($\downarrow$). Voici deux exemples de tels chemins dans une même matrice $A$ de 4 lignes et 4 colonnes : \\
	\begin{center}
		\begin{tabularx}{0.8\textwidth}{YY}
			$\renewcommand\arraystretch{2}
				\begin{pmatrix}
					\circlenode{a}{2} & 5                 & 4                 & 6                 \\
					\circlenode{b}{8} & 5                 & 9                 & 8                 \\
					\circlenode{c}{5} & \circlenode{d}{7} & \circlenode{e}{4} & 6                 \\
					9                 & 6                 & \circlenode{f}{4} & \circlenode{g}{4} \\
				\end{pmatrix}$
			\ncline{->}{a}{b}
			\ncline{->}{b}{c}
			\ncline{->}{c}{d}
			\ncline{->}{d}{e}
			\ncline{->}{e}{f}
			\ncline{->}{f}{g}                   &
			$    \renewcommand\arraystretch{2}
				\begin{pmatrix}

					\circlenode{a}{2} & \circlenode{b}{5} & \circlenode{c}{4} & 6                 \\
					8                 & 5                 & \circlenode{d}{9} & \circlenode{e}{8} \\
					5                 & 7                 & 4                 & \circlenode{f}{6} \\
					9                 & 6                 & 4                 & \circlenode{g}{4} \\
				\end{pmatrix}$
			\ncline{->}{a}{b}
			\ncline{->}{b}{c}
			\ncline{->}{c}{d}
			\ncline{->}{d}{e}
			\ncline{->}{e}{f}
			\ncline{->}{f}{g}
			\\
			Un exemple $C_1$ de chemin dans $A$ & Un exemple $C_2$ de chemin dans $A$ \\
		\end{tabularx} \end{center}
	On appelle \textit{somme d'un chemin} dans une matrice $M$, la somme des coefficients $M_{i,j}$ rencontrés en suivant ce chemin. Dans les exemples ci-dessus, le chemin $C_1$ a une somme de $34$ et le chemin $C_2$ a une somme de $38$. Le but du problème est d'étudier divers algorithmes qui cherchent à déterminer un chemin dont la somme est maximale.\\
	\ExePart[name = {Un premier algorithme naïf}]\\
	On propose l'algorithme suivant afin de résoudre ce problème  : si les deux directions bas ou droite sont possibles on choisit celle qui mène vers le coefficient de matrice le plus élevé, en cas d'égalité, on choisit (arbitrairement) la direction bas. Dans l'exemple ci-dessus à partir de $M_{0,0}=2$ on peut aller vers à droite vers $M_{0,1} = 5$ ou en bas vers $M_{1,0}=8$ et on choisit donc d'aller en bas puisque $8>5$. Une fois arrivé en $M_{1,0}$ les deux directions possibles mènent vers des coefficients identiques (5 des deux côtés) et donc, on va vers le bas. Enfin, lorsqu'une seule direction est possible (parce qu'on a atteint la dernière colonne ou la dernière ligne), c'est cette direction qui est choisie.
	\Question{Poursuivre le déroulement de cet algorithme sur la matrice $A$ donnée en exemple ci-dessus, dessiner le chemin obtenu et donner sa somme.}
	\tcor{$\renewcommand\arraystretch{2} \begin{pmatrix}
		\circlenode{a}{2} & 5                 & 4                 & 6                 \\
		\circlenode{b}{8} & 5                 & 9                 & 8                 \\
		\circlenode{c}{5} & 7 & 4 & 6                 \\
		\circlenode{d}{9}                 & \circlenode{e}{6}                 & \circlenode{f}{4} & \circlenode{g}{4} \\
	\end{pmatrix}$
\ncline{->}{a}{b}
\ncline{->}{b}{c}
\ncline{->}{c}{d}
\ncline{->}{d}{e}
\ncline{->}{e}{f}
\ncline{->}{f}{g} \\ Le chemin obtenu a une somme de $2 + 8 + 5 + 9 + 6  + 4 + 4 = 38$}
	\Question{Dans quelle famille d'algorithme peut-on classer cet algorithme ? Justifier.}
	\tcor{C'est un algorithme glouton car à chaque étape on choisit un maximum \textit{local} sans se préoccuper de l'impact de ce choix sur le maximum global.}
	\Question{Donner la complexité de cet algorithme.}
	\tcor{On doit choisir un nombre de directions qui dépend linéairement de la taille de la matrice $n$, chaque choix compare deux valeur et donc s'effectue en temps constant. C'est donc un algorithme de complexité linéaire.}
	\Question{Montrer en exhibant un exemple dans le cas $n=4$ que cet algorithme ne fournit par toujours un chemin de somme maximale.}
	\tcor{On a obtenu sur l'exemple une somme de $38$, or dans cette même matrice, un autre chemin donne une somme supérieure : \\
	$\renewcommand\arraystretch{2} \begin{pmatrix}
		\circlenode{a}{2} & 5                 & 4                 & 6                 \\
		\circlenode{b}{8} & \circlenode{c}{5}                 & \circlenode{d}{9}                 & \circlenode{e}{8}                 \\
		5 & 7 & 4 & \circlenode{f}{6}                 \\
		9                 & 6                 & 4 & \circlenode{g}{4} \\
	\end{pmatrix}$
\ncline{->}{a}{b}
\ncline{->}{b}{c}
\ncline{->}{c}{d}
\ncline{->}{d}{e}
\ncline{->}{e}{f}
\ncline{->}{f}{g} \\ Le chemin obtenu a une somme de $2 + 8 + 5 + 9 + 8  + 2 + 4 = 42$
	}
	\Question{Montrer que pour une matrice de taille $n$, un chemin de $M_{0,0}$ à $M_{n-1,n-1}$ est constitué de $2n-2$ directions.}
	\tcor{On doit effectuer $n-1$ déplacements vers la droite afin de passer de la colonne $0$ à la colonne $n-1$. De même on effectue $n-1$ déplacements vers le bas afin de passer de la ligne $0$ à la ligne $n-1$. Ce qui donne un total de $2n-2$ déplacements.}
	\Question{On définit le type :
	\inputpartOCaml{crossmax.ml}{}{}{2}{2}
	Ecrire une fonction {\tt choix : int array array -> int -> int -> direction} qui prend en argument une matrice d'entiers {\tt M}, une ligne {\tt lig} et une colonne  {\tt col} et renvoie {\tt Bas} ou {\tt Droite} suivant le choix effectué par l'algorithme décrit ci-dessus à partir de la position située à la ligne {\tt lig} à la colonne {\tt col} de la matrice {\tt M}.
	}
	\tcor{\inputpartOCaml{crossmax.ml}{}{}{93}{96}}
	\Question{Ecrire une fonction {\tt naïf int array array -> direction array} qui prend en entrée une matrice d'entiers {\tt M} et renvoie le chemin fournit par l'algorithme naïf décrit ci-dessus.}
	\tcor{\inputpartOCaml{crossmax.ml}{}{}{98}{107}}
	\Question{Ecrire une fonction {\tt somme int array array -> direction array -> int} qui prend en entrée une matrice d'entiers {\tt M}, un chemin dans cette matrice et renvoie la somme de ce chemin.}
	\tcor{\inputpartOCaml{crossmax.ml}{}{}{4}{13}}
	\ExePart[name = {Résolution exacte par force brute}] \\
	On propose l'algorithme par force brute qui consiste à énumérer tous les chemins possibles de $M_{0,0}$ vers $M_{n-1,n-1}$ à calculer leur somme puis à renvoyer la somme maximale atteignable. Afin de décrire un chemin on le fait correspondre à un tableau de $n-1$ entiers compris entre $1$ et $2n-2$, qui indique la position des {\tt Bas} dans le chemin. Par exemple pour $n=3$, le chemin {\tt [| Bas; Droite; Bas; Droite |]} sera représenté par {\tt [| 1; 3 |]} car les {\tt Bas} se trouvent en première et troisième position du tableau. De la même façon, le chemin $C_1$ donné en exemple en début d'énoncé dans le cas $n=4$ est {\tt [| Bas; Bas; Droite; Droite; Bas; Droite |]} et sera donc représenté par {\tt [| 1; 2; 5 |]}.
    \Question{A quel chemin correspond le tableau d'entiers {\tt [| 3; 5; 6 |]} ? }
	\tcor{Le tableau {\tt [|3; 5; 6|]} correspond au chemin {\tt [| Droite; Droite; Bas; Droite; Bas; Bas |]}}
    \Question{Ecrire  une fonction {\tt cree\_chemin int array -> direction array} qui prend en argument un tableau d'entiers  et renvoie le chemin  correspondant. Par exemple, {\tt cree\_chemin [| 4; 1 |]} renvoie le tableau {\tt [| Bas; Droite; Droite; Bas |]}.}
	\tcor{\inputpartOCaml{crossmax.ml}{}{}{49}{55}}
	\Question{Ecrire en OCaml une fonction {\tt entiers : int -> int list}} qui prend en entrée un entier {\tt n} et renvoie la liste des entiers de {\tt n} à {\tt 1}. Par exemple {\tt entiers 4} renvoie la liste {\tt [4; 3; 2; 1]}.
	\tcor{\inputpartOCaml{crossmax.ml}{}{}{15}{16}}
	\Question{On souhaite maintenant énumérer les tableaux d'entiers représentant les chemins. Ecrire en OCaml une fonction {\tt chemins :  int -> int array list} qui prend en argument un entier {\tt n}  et renvoie la liste des tableaux d'entiers représentant les chemins possibles. Par exemple {\tt chemins 2} renvoie {\tt [[| 4; 3 |]; [| 4; 2 |]; [| 4; 1 |]; [| 3; 2 |]; [| 3; 1 |]; [| 2; 1 |]]}.}
	\tcor{\inputpartOCaml{crossmax.ml}{}{}{38}{47}}
	\Question{En déduire une fonction {\tt force\_brute : int array array -> int} qui prend en entrée une matrice d'entiers et renvoie la somme maximale atteignable en traversant cette matrice.}
	\tcor{\inputpartOCaml{crossmax.ml}{}{}{57}{64}}
    \Question{Montrer que pour une matrice  $M$ de $n$ lignes et $n$ colonnes, il existe $\binom{2n-2}{n-1}$ chemins possibles de $M_{0,0}$ vers $M_{n-1,n-1}$.}
	\tcor{Choisir un chemin revient à choisir la position des directions {\tt Bas} dans ce chemin. Or, on sait qu'il y en a tout $n-1$ directions {\tt Bas} dans chaque chemin et qu'un chemin est constitué de $2n-2$ directions. Donc il y a en tout $\binom{2n-2}{n-1}$ chemins.}
	\Question{En déduire la complexité de l'algorithme par force brute en admettant que le calcul de la somme d'un chemin donné est en $O(n)$ où $n$ est la longueur de ce chemin. On pourra utiliser la formule de Stirling : $n! \sim \left(\frac{n}{e}\right)^n\sqrt{2 \pi n}$.}
	\tcor{On utilise la formule de Stirling afin de trouver un équivalent asymptotique de $\binom{2n-2}{n-1}$, en notant $m=n-1$ : \\
	$\begin{array}{lll}
		\displaystyle{\binom{2m}{m}} & = & \dfrac{(2m)!}{(m!)^2}  \\
					& = & \left( \dfrac{2m}{e} \right)^{2m} \times \left( \dfrac{e}{m} \right)^{2m} \dfrac{\sqrt{4\pi m}}{2\pi m}\\
					& = & \dfrac{4^m}{\sqrt{\pi m}} \\
	\end{array}$ \\
	Comme pour chaque chemin, le calcul de la longueur est un $O(n)$, on obtient finalement une complexité $O(4^{n-1}\,\sqrt{n})$, c'est à dire une complexité exponentielle. L'algorithme est donc inutilisable en pratique pour de grandes valeurs de $n$.
	}
	\ExePart[name = {Résolution par programmation dynamique}] \\
	Etant donné une matrice carré $M$ de taille $n$ on note $S$ la matrice dont le coefficient situé ligne $i$ colonne $j$ est la somme maximale des chemins  de $M_{0,0}$ vers $M_{i,j}$, on a donc $S_{0,0}=M_{0,0}$.
	\Question{Ecrire la relation de recurrence permettant de calculer les $S_{0,k}$ pour $1 \leqslant k \leqslant n-1$.}
	\tcor{On reste sur la ligne d'indice 0 en allant de la colonne 0 à la colonne $k$, donc pour $1 \leqslant k \leqslant n-1$ $S_{0,k} = S_{0,k-1} + M_{0,k}$. Comme on connaît $S_{0,0} = M_{0,0}$ on peut donc calculer les $S_{0,k}$ de proche en proche.}
	\Question{Ecrire la relation de recurrence permettant de calculer les $S_{k,0}$ pour $1 \leqslant k \leqslant n-1$.}
	\tcor{De la même façon, pour $1 \leqslant k \leqslant n-1$ $S_{k,0} = S_{k-1,0} + M_{k,0}$}
	\Question{Montrer que pour $i$ et $j$ non nuls, $S_{i,j} = \max \left\{ S_{i-1,j}, S_{i,j-1} \right\} + M_{i,j}$.} 
	\tcor{Pour arriver en $S_{i,j}$, on peut avoir suivi la direction {\tt Bas} et donc venir de $M_{i-1,j}$ soit avoir suivi la direction {\tt Droite} et donc venir de $M_{i,j-1}$. La valeur maximale des chemins menant en $M_{i-1,j}$ est par définition $S_{i-1,j}$ et la valeur maximale des chemins menant en $M_{i,j-1}$ est $M_{i,j-1}$. Donc $S_{i,j} = \max \left\{ S_{i-1,j}, S_{i,j-1} \right\} + M_{i,j}$}
    \Question{Ecrire une fonction \textit{récursive} qui calcule de façon descendante les coefficients de la matrice $S$.}
	\inputpartOCaml{crossmax.ml}{}{}{81}{85}
    \Question{Faire un schéma des appels récursifs de la fonction précédente, que peut-on en conclure ?}
	\tcor{On constate un chevauchement des appels récursifs, il faut utiliser la mémoïsation ou une version ascendante pour résoudre le problème.}
	\Question{Ecrire une fonction OCaml \textit{itérative} {\tt somme\_maxi int array array -> int array array} qui prend en argument une matrice $M$ et calcule de façon ascendante les coefficients de la matrice $S$.}
	\inputpartOCaml{crossmax.ml}{}{}{66}{79}
	\Question{Déterminer la complexité de cette fonction en fonction $n$.}
	\tcor{La complexité est quadratique en la taille $n$ de la matrice.}
\end{Exercise}

\begin{Exercise}[title = {Liste chaînée circulaire}]\\
    Le langage utilisé dans cette partie est le langage C. \smallskip\\ 
	On veut implémenter une structure de données de liste chainée circulaire avec un pointeur sur la queue telle que représentée ci-dessous :
	\begin{center}
		\begin{tabular}{ccllllc}
			                                           &                         &                         &                         &                         & \rnode{liste}{{\footnotesize queue}} & \\
			                                           &                         &                         &                         &                         &                                      & \\
			\rnode{head}{\raisebox{-2pt}{\phantom{Y}}} & \maillon{$e_0$}{v0}{p0} & \maillon{$e_1$}{v1}{p1} & \maillon{$e_2$}{v2}{p2} & \maillon{$e_3$}{v3}{p3} & \maillon{$e_4$}{v4}{p4}              & \\
		\end{tabular}\\
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p0}{v1}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p1}{v2}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p2}{v3}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p3}{v4}
		\ncline[nodesepB=0.25cm,nodesepA=0.05cm]{*->}{liste}{v4}
		\ncbar[nodesepB=0.2cm,nodesepA=-0.2cm,angleA=-90,angleB=-90]{*->}{p4}{v0}
	\end{center} \bigskip
	La queue pointe toujours vers \textit{le dernier élément inséré} ainsi, après l'ajout d'un nouvel élément $e_5$, la structure de donnée ci-dessus devient :
	\begin{center}
		\begin{tabular}{ccllllcl}
			                                           &                         &                         &                         &                         &                         & \hspace{-0.6cm}\rnode{liste}{{\footnotesize queue}} & \\
			                                           &                         &                         &                         &                         &                         &                                                        \\
			\rnode{head}{\raisebox{-2pt}{\phantom{Y}}} & \maillon{$e_0$}{v0}{p0} & \maillon{$e_1$}{v1}{p1} & \maillon{$e_2$}{v2}{p2} & \maillon{$e_3$}{v3}{p3} & \maillon{$e_4$}{v4}{p4} & \maillon{$e_5$}{v5}{p5}                                \\
		\end{tabular}\\
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p0}{v1}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p1}{v2}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p2}{v3}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p3}{v4}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p4}{v5}
		\ncline[nodesepB=0.25cm,nodesepA=0.05cm]{*->}{liste}{v5}
		\ncbar[nodesepB=0.2cm,nodesepA=-0.2cm,angleA=-90,angleB=-90]{*->}{p5}{v0}
	\end{center} \bigskip
	Lorsqu'on retire un élément de cette structure de données, on retire le maillon qui suit le dernier élément inséré. Par conséquent, si on retire un élément de la structure de donnée ci-dessus, c'est le maillon contenant $e_0$ qui est retiré et on obtient :
	\begin{center}
		\begin{tabular}{ccllllcl}
			                                           &  &                         &                         &                         &                         & \hspace{-0.6cm}\rnode{liste}{{\footnotesize queue}} & \\
			                                           &  &                         &                         &                         &                         &                                                        \\
			\rnode{head}{\raisebox{-2pt}{\phantom{Y}}} &  & \maillon{$e_1$}{v1}{p1} & \maillon{$e_2$}{v2}{p2} & \maillon{$e_3$}{v3}{p3} & \maillon{$e_4$}{v4}{p4} & \maillon{$e_5$}{v5}{p5}                                \\
		\end{tabular}\\
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p1}{v2}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p2}{v3}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p3}{v4}
		\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p4}{v5}
		\ncline[nodesepB=0.25cm,nodesepA=0.05cm]{*->}{liste}{v5}
		\ncbar[nodesepB=0.2cm,nodesepA=-0.2cm,angleA=-90,angleB=-90]{*->}{p5}{v1}
	\end{center} \bigskip
	Afin d'implémenter cette structure de données, on propose d'utiliser les types suivants
	\inputpartC{file.c}{}{}{5}{11}
	La liste chainée circulaire vide est alors représentée par le pointeur {\sc null}.
    \Question{En partant d'une liste chainée circulaire initialement vide, donner les étapes de son évolution après les opérations suivantes  : \begin{enumerate}
    \item {\tt ajouter 12}
    \item {\tt ajouter  6}
    \item {\tt ajouter  7}
    \item {\tt retirer }
    \item {\tt ajouter 42}
    \item {\tt retirer} 
    \end{enumerate}
    On précisera la valeur des entiers renvoyés par la fonction {\tt Retirer}.
    }
	\tcor{
	\begin{enumerate}
		\item {\tt ajouter 12} : {\tt \underline{12}}
		\item {\tt ajouter  6} : {\tt 12} $\rightarrow$ {\tt \underline{6}}
		\item {\tt ajouter  7} : {\tt 12} $\rightarrow$ {\tt 6} $ \rightarrow$ {\tt \underline{7}}
		\item {\tt retirer } : {\tt 6} $\rightarrow$ {\tt \underline{7}}, l'opération renvoie 12
		\item {\tt ajouter 42}: {\tt 6} $\rightarrow$ {\tt 7} $\rightarrow${\tt \underline{42}}
		\item {\tt retirer} : {\tt 7} $\rightarrow${\tt \underline{42}}, l'opération renvoie 6
	\end{enumerate}
	}
	\Question{Pour ajouter un élément dans une liste circulaire, on propose la fonction ci-dessous :
		\inputpartC{file.c}{}{}{35}{42}
		Indiquer, en justifiant votre réponse, quelle ligne de cette fonction est problématique si la liste circulaire {\tt lc} est vide.
	}
	\tcor{Si la liste circulaire est vide alors {\tt lc} est le pointeur {\sc null}, donc la ligne 5 est problématique car c'est un comportement indéfini, il s'agit du déréférencement du pointeur {\tt null}.}
	\Question{Corriger la fonction {\tt ajouter\_errone} afin de traiter convenablement le cas où la liste circulaire {\tt lc} est vide.}
	\tcor{\inputpartC{file.c}{}{}{18}{32}}
	\Question{Ecrire la fonction {\tt retirer} de signature \mintinline{c}{int retirer(liste_circulaire *lc)} qui prend en argument une liste circulaire \textit{supposée non vide} et renvoie la valeur du maillon situé après le pointeur de queue en le retirant de la liste circulaire.}
	\tcor{\inputpartC{file.c}{}{}{44}{58}}
	\Question{Quelle structure de données connue a-t-on implémenté ici ? Justifier et proposer des noms plus appropriés pour les fonctions {\tt ajouter} et {\tt retirer}.}
	\tcor{Les premiers éléments ajoutés à la structure sont aussi les premiers à être retirés, il s'agit donc d'une file {\sc fifo}. L'opération ajouter correspond à enfiler et l'opération retirer à défiler.}
	\Question{Ecrire une fonction {\tt longueur} de signature \mintinline{c}{int longueur(liste_circulaire *lc)} qui renvoie le nombre d'éléments d'une liste chaînée circulaire.}
	\tcor{\inputpartC{file.c}{}{}{59}{69}}
	\Question{Donner, en les justifiant, les complexités des opérations {\tt retirer}, {\tt ajouter} et {\tt longueur}.}
	\tcor{retirer et ajouter sont en $O(1)$ car on ne fait que des opérations élémentaires et longueur est en $O(n)$ où $n$ est la longueur de la liste car celle ci doit être parcourue en entier (on détecte un retour vers le pointeur initial).}
\end{Exercise}

\end{document}