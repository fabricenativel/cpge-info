\documentclass[11pt,a4paper]{article}

\usepackage{Act}

\begin{document}
\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/Macros.tex}}
\ModeExercice
\TD{7}{Structure de données linéaires}

\setcounter{Exercise}{0}

\begin{Exercise}[title = {complexité des opérations}]
    On considère les structures de données suivantes :
    \begin{itemize}
        \item Un tableau de taille fixe
        \item Une pile implémentée à l'aide d'une liste simplement chainée
        \item Une file implémentée à l'aide d'une liste simplement chainée ayant un accès sur son dernier élément
    \end{itemize}
    Donner la complexité des opérations suivantes sur chacune de ces structures de données :
    \Question{Accès au n-ième élément}
    \Question{Insertion d'un élément au début (au sommet pour la pile)}
    \Question{Insertion à la fin (tout en bas pour la pile)}
    \Question{Suppression du premier élément}
    \Question{Suppression du dernier élément}
    \Question{Test d'appartenance d'un élément}
\end{Exercise}


\begin{Exercise}[title={Inversion au sommet}]\\
    On suppose qu'on dispose d'une structure de données de type pile dotée de son interface habituelle c'est-à-dire {\tt empiler}, {\tt dépiler} et {\tt est\_vide}.
    Proposer une suite d'opérations permettant d'inverser, lorsqu'ils existent, les deux éléments situés au sommet de cette pile.
    Si la pile contient moins de deux éléments, elle doit rester en l'état.
\end{Exercise}

\begin{Exercise}[title={Taille d'une file}]\\
    Ecrire une fonction prenant en entrée une file file $F$ et renvoyant sa taille. La file $F$ ne doit pas être détruite mais restituée à son état initial et on ne dispose que de l'interface usuelle d'une file (qu'on rapellera).
\end{Exercise}


\begin{Exercise}[title={list de OCaml}]
\Question{Rappeler la complexité de l'opérateur {\tt ::} en OCaml. Expliquer cette complexité}
\Question{Même question pour {\tt @}}
\Question{On considère deux listes en OCaml : {\tt l1=[2; 4; 8]} et {\tt l2=[2; 3; 5; 7]}. Réprésenter en mémoire la liste {\tt l} obtenue à l'aide de \mintinline{ocaml}{let l = l1@l2;;}}
\end{Exercise}

\begin{Exercise}[title={Un exemple de complexité amortie}]\\
On prend l'exemple de la structure de données implémentant le type de \textit{list} de Python grâce à un tableau dynamique en C (voir TP). On considère un tableau donc la taille initiale est 1 et sur lequel on effectue $n$ opérations {\tt append}. Le but de l'exercice est de montrer qu'on obtiendra alors un nombre d'opérations en $O(n)$. On dira alors que le {\tt append} a une \textbf{complexité amortie} en $O(1)$.

\Question{Montrer que le coût du redimensionnement d'un tableau de taille $n$ est un $O(n).$} 
\Question{Montrer que $n$ opérations {\tt append} vont nécessiter $\lfloor\log_2(n)\rfloor$ redimensionnement de tableau}.
\Question{Donner la taille des tableaux lors de chaque redimensionnement.}
\Question{En déduire le coût des redimensionnements.}
\Question{Montrer que le coût total est un $O(n)$.}
\end{Exercise}

\begin{Exercise}[title={Implémentation d'une file avec deux piles}]\\
    On reprend l'implémentation d'une file avec deux piles (voir TP), le but de l'exercice est d'établir la complexité de {\tt défiler}
    \Question{Donner les complexités dans le pire et le meilleur des cas}
    \Question{On suppose à présent qu'en tout on a enfilé et défilé $n$ éléments. Montrer que le nombre total d'opérations nécessaire est un $O(n)$.}
\end{Exercise}
    



\end{document}