\PassOptionsToPackage{dvipsnames,table}{xcolor}
\documentclass[10pt]{beamer}
\usepackage{Cours}

\begin{document}

\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/MacrosCours.tex}}

% Numéro et titre de chapitre
\setcounter{numchap}{12}
\newcommand{\Ctitle}{\cnum {Arbres binaires}}
\newcommand{\SPATH}{/home/fenarius/Travail/Cours/cpge-info/docs/mp2i/files/C\thenumchap/}
\newcommand{\NR}[1]{\TCircle[fillstyle=solid,fillcolor=red!20!white,linecolor=red,radius=0.25cm]{#1}}
\newcommand{\NN}[1]{\TCircle[fillstyle=solid,fillcolor=black!20!white,linecolor=black,radius=0.25cm]{#1}}
% Exemple introductif
\makess{Définition}
\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{alertblock}{Définition}
		Un \textcolor{blue}{arbre binaire}, est une structure de données \textit{hiérarchique} (les éléments, appelés \textcolor{blue}{noeuds} sont rangés par niveau) qui peut se définir récursivement.\\
		En effet, un arbre binaire est
		\begin{itemize}
			\item<2-> soit vide, on le note alors $\varnothing$
			\item<3-> soit un noeud $(sag,r,sad)$  appelé \textcolor{blue}{racine} où $r$ est l'étiquette de la racine et $sag$ et $sad$ sont deux arbres binaires (le sous arbre gauche, et le sous arbre droit)
		\end{itemize}
	\end{alertblock}
	\begin{exampleblock}{Exemples}
		\onslide<4->{\small L'arbre $(\varnothing,a,(\varnothing,b,\varnothing))$\\}
		\onslide<5->{
			\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$a$}}{
				\Tr{$\varnothing$}
				\pstree{\TCircle[radius=0.25cm]{$b$}}{
					\Tr{$\varnothing$}
					\Tr{$\varnothing$}
				}
			} \quad \quad \quad }
		\onslide<6->
		{
			\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$a$}}{
				\Tn{}
				\TCircle[radius=0.25cm]{$b$}
			}
			\\}
		\onslide<7->{\small Représenté avec (à gauche) ou sans (à droite) les sous arbres vides.}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Remarques}
		\begin{itemize}
			\item<1->{\small \textcolor{BrickRed}{\danger}} Les deux arbres ci-dessous sont \textcolor{blue}{différents} !\\
			\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$a$}}{
				\Tr{$\varnothing$}
				\pstree[arrows=->]{\TCircle[radius=0.25cm]{$b$}}{
					\Tr{$\varnothing$}
					\Tr{$\varnothing$}
				}
			} \quad \quad \quad
			\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$a$}}{
				\pstree{\TCircle[radius=0.25cm]{$b$}}{
					\Tr{$\varnothing$}
					\Tr{$\varnothing$}
				}
				\Tr{$\varnothing$}
			} \quad \quad \quad
			\item<2-> On omet parfois de représenter les sous arbres vides, mais on doit garder à l'esprit qu'un noeud non vide est \textit{toujours} un triplet. Et que donc les sous arbres gauche et droit même vide, sont toujours présents.
			\item<3-> Lorsque qu'un noeud $a$ possède un sous arbre non vide dont la racine est $b$, on dit que $a$ est le \textcolor{blue}{père} de $b$ et que $b$ est le \textcolor{blue}{fils} $a$.
			\item<4-> Un noeud dont les deux sous arbres sont vides s'appelle une \textcolor{blue}{feuille}.
			\item<5-> un noeud qui n'est pas une feuille s'appelle un \textcolor{blue}{noeud interne}.
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Définition récursive du nombre de noeuds et de la hauteur}
		\begin{itemize}
			\item Le \textcolor{blue}{nombre de noeuds} d'un arbre binaire $A$, noté $n(A)$, se définit récursivement par :
			      \onslide<2->{
				      $$ \left\{
					      \begin{array}{llll}
						      n(A) & = & 0               & \text{si $A$ est vide}  \\
						      n(A) & = & 1 + n(g) + n(d) & \text{si $A = (g,a,d)$} \\
					      \end{array}
					      \right.
				      $$}
			\item<3-> La \textcolor{blue}{hauteur} d'un arbre binaire $A$, noté $h(A)$, se définit récursivement par :
				\onslide<4->{
					$$ \left\{
						\begin{array}{llll}
							h(A) & = & -1                  & \text{si $A$ est vide}  \\
							n(A) & = & 1 + \max(h(g),h(d)) & \text{si $A = (g,a,d)$} \\
						\end{array}
						\right.
					$$}
				\onslide<5->{\textcolor{BrickRed}{\small \danger} Certains auteurs prennent $0$ comment hauteur de l'arbre vide.}
				\item<6->La \textcolor{blue}{profondeur} d'un noeud est sa distance à la racine.
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Exemple}
		\begin{center}
			\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$r$}}{
				\Tn{}
				\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$k$}}
				{
					\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$e$}}{
						\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$p$}}{
							\TCircle[radius=0.25cm]{$l$}
							\TCircle[radius=0.25cm]{$u$}
						}
						\Tn{}
					}
					\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$c$}}{
						\Tn{}
						\TCircle[radius=0.25cm]{$z$}}
				}
			}
		\end{center}
		\begin{itemize}
			\item<2-> Nommer les feuilles et les noeuds internes
			\item<3-> Donner le nombre de noeuds
			\item<4-> Donner la hauteur de cet arbre
			\item<5-> Donner un noeud de profondeur 2
			\item<6-> Donner l'écriture de cet arbre sous forme de triplet
		\end{itemize}
	\end{exampleblock}
\end{frame}


% Cas particuliers d'arbres binaires
\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Quelques cas particuliers}
		\begin{itemize}
			\item Un arbre binaire est dit \textcolor{blue}{dégénéré} lorsque tous les noeuds à l'exception des feuilles n'ont qu'un fils. \\
			      \onslide<2->{
				      \begin{tabularx}{\linewidth}{YYY}
					      \pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
						      \Tn{}
						      \pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
							      \Tn{}
							      \pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
								      \Tn{}
								      \pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
									      \Tn{}
								      }}}}
					       &
					      \pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
						      \Tn{}
						      \pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
							      \Tn{}
							      \pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{

								      \pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
									      \Tn{}
								      }\Tn{}}}}
					       & \pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
						      \pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
							      \pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
								      \pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
									      \Tn{} } \Tn{}} \Tn{}}                    \Tn{}
					      }
				      \end{tabularx}}
			      \onslide<2-> Pour les arbres représentés à gauche et à droite on parle de \textit{peigne}, à rapprocher de la liste chainée.
		\end{itemize}
	\end{block}
\end{frame}
\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Quelques cas particuliers}
		\begin{itemize}
			\item<2-> Un arbre binaire est dit \textcolor{blue}{parfait} lorsque tous les niveaux sont remplis : \\
				\onslide<3->{
					\begin{center}
						\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}
						{
							\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
								\TCircle[radius=0.25cm]{}
								\TCircle[radius=0.25cm]{}
							}
							\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
								\TCircle[radius=0.25cm]{}
								\TCircle[radius=0.25cm]{}
							}
						}
					\end{center}}
			\item<4-> Un arbre binaire est dit \textcolor{blue}{complet} lorsque tous les niveaux à l'exception du dernier sont remplis et que le dernier niveau est rempli à parti de la gauche. \\
				\onslide<5->{
					\begin{center}
						\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}
						{
							\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
								\TCircle[radius=0.25cm]{}
								\TCircle[radius=0.25cm]{}
							}
							\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{}}{
								\TCircle[radius=0.25cm]{}
								\Tn{}
							}
						}
					\end{center}}
		\end{itemize}
	\end{block}
\end{frame}

% Relation entre hauteur et taille
\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{alertblock}{Nombre de sous abres vides}
		Le nombre de sous arbres vides d'un arbre binaire de taille $n$ est $n+1$.
	\end{alertblock}
	\onslide<2->{
		\begin{alertblock}{Relation entre hauteur et taille}
			En notant $n$ la taille et $h$ la hauteur d'un arbre binaire, on a la relation suivante : \\
			\onslide<3->{$$ { h+1 \leq n \leq 2^{h+1}-1} $$}
		\end{alertblock}}
	\onslide<4->{
		\begin{block}{Remarque}
		On démontrera souvent une propriété $\mathcal{P}$, sur les arbres par récurrence (sur la hauteur ou la taille) ou par \textcolor{blue}{induction structurelle} :
		\begin{itemize}
			\item<5-> $\mathcal{P}$ est vraie sur l'arbre vide,
			\item<6-> Si $\mathcal{P}$ est vraie pour $g$ et $d$ alors $\mathcal{P}$ est vraie pour un arbre dont les sous arbres sont $g$ et $d$.
		\end{itemize}
		\end{block}
		}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Exercices}
		\begin{enumerate}
			\item<1-> Dessiner un arbres binaires de taille 4 dont l'un des noeuds au moins a un fils gauche vide.
			\item<2-> Dessiner un arbre binaire de hauteur taille 4 et de hauteur 3.
			\item<3-> Dessiner un arbre binaire de hauteur 2 et de taille $2^3-1$.
			\item<4-> Montrer que le nombre d'arêtes (trait reliant  un noeud à un fils \textit{non vide}) d'un arbre binaire à $n$ noeuds est $n+1$
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\makess{Représentation  en machine}
\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Type structuré en C}
		En C, on représente un arbre binaire par un pointeur vers un type structuré contenant trois champs : l'étiquette (un {\tt int}) de la racine, et les pointeurs vers les deux sous arbres (gauche et droit). L'arbre vide est le pointeur {\sc null}.
		\onslide<2->{\inputpartC{\SPATH/arbres_binaires.c}{}{}{4}{11}}
	\end{block}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Création d'un arbre}
		\onslide<2->On écrit alors une fonction \mintinline{c}{ab cree_arbre(ab g, int v, ab d)}  qui renvoie un arbre donne on donne l'étiquette de la racine et les deux sous arbres :
		\onslide<3>{\inputpartC{\SPATH/arbres_binaires.c}{}{}{15}{22}}
	\end{block}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Exemple}
		\begin{enumerate}
			\item<1-> En utilisant cette représentation, créer l'arbre binaire suivant :
				\begin{center}
					\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{9}}
					{
						\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{5}}{
							\Tn{}
							\TCircle[radius=0.25cm]{7}
						}
						\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{3}}{
							\TCircle[radius=0.25cm]{4}
							\Tn{}
						}
					}
				\end{center}
			\item<2-> Ecrire la fonction permettant de calculer le nombre de noeuds d'un arbre binaire.
				\onslide<3->{\inputpartC{\SPATH/arbres_binaires.c}{}{}{24}{29}}
		\end{enumerate}
	\end{exampleblock}
\end{frame}


\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Type structuré en OCaml}
		Un arbre binaire étant soit vide soit constituée d'une étiquette ({\tt int} pour simplifier), on le définit en OCaml en envisageant les 2 cas :
		\onslide<2->{\inputpartOCaml{\SPATH/arbres_binaires_int.ml}{}{}{1}{3}}
		On a choisit ici un arbre binaire ayant des étiquettes entières, on aurait pu utiliser un type paramétré {\tt 'a} :
		\onslide<2->{\inputpartOCaml{\SPATH/arbres_binaires.ml}{}{}{1}{3}}
	\end{block}

\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Exemple}
		\begin{enumerate}
			\item<1-> En utilisant cette représentation, créer l'arbre binaire suivant :
				\begin{center}
					\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{2}}
					{
						\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{7}}{
							\Tn{}
							\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{1}}{
								\TCircle[radius=0.25cm]{5}
								\TCircle[radius=0.25cm]{6}}
						}
						\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{3}}{
							\Tn{}
							\TCircle[radius=0.25cm]{4}
						}
					}
				\end{center}
			\item<2-> Ecrire la fonction permettant de calculer le nombre de noeuds d'un arbre binaire et donner sa complexité.
				\onslide<3->{\inputpartOCaml{\SPATH/arbres_binaires.ml}{}{}{6}{9}}
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Cas particulier d'un arbre binaire complet}
		\onslide<2->{Un arbre binaire complet de taille $n$ peut être représenté de façon compacte à l'aide d'un tableau de taille $n$.}
		\onslide<3->{On numérote les noeuds depuis la racine, de gauche à droite et de haut en bas, le noeud numeroté $i$ est placé dans la case d'indice $i$.}
		\onslide<4->{Par exemple :
			\begin{center}
				\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{4} \alt<5->{\nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{blue}{\scriptsize 0}}}{}}
				{
					\pstree[treesep=0.5cm,levelsep=0.7cm]{
						\TCircle[radius=0.25cm]{5} \alt<5->{\nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{blue}{\scriptsize 1}}}{}}{
						\TCircle[radius=0.25cm]{2} \alt<5->{\nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{blue}{\scriptsize 3}}}{}
						\TCircle[radius=0.25cm]{7} \alt<5->{\nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{blue}{\scriptsize 4}}}{}
					}
					\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{9} \alt<5->{\nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{blue}{\scriptsize 2}}}{}}{
						\TCircle[radius=0.25cm]{8} \alt<5->{\nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{blue}{\scriptsize 5}}}{}
						\Tn{}
					}
				}\vspace{0.2cm}
			\end{center}}
		\onslide<6->{sera représenté par le tableau :}
		\onslide<7->{
			\begin{tabular}{|c|c|c|c|c|c|}
				\hline
				4                                                   & 5                                                   & 9                                                   & 2                                                   & 7                                                   & 8                                                   \\
				\hline
				\multicolumn{1}{c}{\textcolor{blue}{\scriptsize 0}} & \multicolumn{1}{c}{\textcolor{blue}{\scriptsize 1}} & \multicolumn{1}{c}{\textcolor{blue}{\scriptsize 2}} & \multicolumn{1}{c}{\textcolor{blue}{\scriptsize 3}} & \multicolumn{1}{c}{\textcolor{blue}{\scriptsize 4}} & \multicolumn{1}{c}{\textcolor{blue}{\scriptsize 5}} \\
			\end{tabular}}
		\begin{itemize}
			\item<8-> Le fils gauche (resp. droit) du noeud $i$ se trouve à l'indice $2i+1$ (resp.) $2i+2$.
			\item<9-> Le père du noeud d'indice i se trouve à l'indice $\pe{\dfrac{i-1}{2}}$.
		\end{itemize}
	\end{block}
\end{frame}

\makess{Parcours d'un arbre binaire}
\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{alertblock}{Parcours récursifs}
		On appelle \textit{parcours d'un arbre binaire} un algorithme permettant de visiter chaque noeud de cet arbre une et une seule fois afin d'y effectuer un traitement (tester la présence d'une valeur, chercher la plus petite valeur, \dots).
		\onslide<2->{Compte tenu de la structure récursive des arbres binaires, trois parcours récursifs émergent suivant le choix du moment où on traite la racine du noeud ($g,r,d$) : }
		\begin{itemize}
			\item<3-> Dans le parcours \textcolor{blue}{préfixe}, la racine est traitée avant de relancer le parcours sur  le sous arbre gauche $g$ et le sous arbre droit $d$.
			\item<4-> Dans le parcours \textcolor{blue}{infixe}, la racine est traitée après le parcours du sous arbre gauche $g$ mais avant celui du sous arbre droit  $d$.
			\item<5-> Dans le parcours \textcolor{blue}{suffixe}, la racine est traitée  après le parcours du sous arbre gauche $g$ et du sous arbre droit $d$.
		\end{itemize}
	\end{alertblock}
\end{frame}


\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Exemple}
		\begin{center}
			\begin{tabular}{p{0.3cm}p{0.3cm}p{0.3cm}p{0.3cm}p{0.3cm}p{0.3cm}p{0.3cm}}
				                    &                     &                     & \circlenode{A}{{R}} &                     &                     & \phantom{0}\vspace{0.5cm} \\
				                    & \circlenode{B}{T}   &                     &                     &                     & \circlenode{C}{{C}} & \phantom{0}\vspace{0.5cm} \\
				\circlenode{D}{{V}} &                     & \circlenode{E}{{I}} &                     & \circlenode{F}{{F}} &                     & \phantom{0}\vspace{0.5cm} \\
				                    & \circlenode{I}{{M}} &                     & \circlenode{G}{{P}} &                     & \circlenode{H}{{A}} &                           \\
				\ncline{->}{A}{B} \ncline{->}{A}{C} \ncline{->}{B}{D} \ncline{->}{B}{E} \ncline{->}{F}{G} \ncline{->}{F}{H} \ncline{C}{F} \ncline{D}{I}
			\end{tabular}
		\end{center}
		Donner l'ordre des noeuds lorsqu'on parcourt l'arbre ci-dessus :
		\begin{itemize}
			\item<2-> En profondeur préfixé : \onslide<3->{R, T, V, M, I, C, F, P, A}
			\item<4-> En profondeur infixé : \onslide<5->{V, M, T, I, R, P, F, A, C}
			\item<6-> En profondeur suffixé : \onslide<7->{M, V, I, T, P, A, F, C, R}
		\end{itemize}
	\end{exampleblock}
\end{frame}


\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{alertblock}{Parcours en largeur}
		La parcours en largeur revient à lister les noeuds par ordre croissant de profondeur et de gauche à droite \\
		\onslide<2-> L'implémentation de ce parcours peut se faire à l'aide d'une file dans laquelle on stocke les noeuds restants à parcourir. A chaque fois qu'on traite un noeud, on le defile et on enfile ses fils.
	\end{alertblock}
	\onslide<3->{
	\begin{exampleblock}{Exemple}
		\begin{center}
			\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{S}}
			{
				\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{U}}{
					\Tn{}
					\TCircle[radius=0.25cm]{E}
				}
				\pstree[treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{P}}{
					\TCircle[radius=0.25cm]{R}
					\Tn{}
				}
			}
		\end{center}\vspace{0.2cm}}
		\onslide<4-> {Le parcours en largeur donne : S, U, P, E, R.}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Exemple d'implémentation}
		\begin{itemize}
			\item<1-> Parcours prefixe en C (affichage des étiquettes)
				\onslide<2->{\inputpartC{\SPATH/arbres_binaires.c}{}{\footnotesize}{88}{96}}
			\item<3-> Parcours infixe en OCaml (affichage des étiquettes)
				\onslide<2->{\inputpartOCaml{\SPATH/arbres_binaires.ml}{}{\footnotesize}{56}{59}}
		\end{itemize}
	\end{block}
\end{frame}

\makess{Arbres binaires de recherche}
\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{alertblock}{Arbre binaire de recherche}
		Un arbre binaire \textcolor{blue}{de recherche} (noté {\sc abr}), est un arbre binaire tel que :
		\begin{itemize}
			\item<2-> Les étiquettes des noeuds, appelées \textcolor{blue}{clés} sont toutes comparables entre elles. \\
				\onslide<4->{\textcolor{gray}{Par exemple, les étiquettes sont toutes des nombres ou encore des chaines de caractères (comparées par ordre alphabétique).}}
			\item<5-> Pour tous les noeuds $N(g,v,d)$ l'ensemble des clés présentes dans le sous arbre gauche $g$ (resp. droit $d$) sont strictement inférieures (resp. supérieures) à $v$.\\
				\item<6->{Les clés sont \textcolor{blue}{uniques}.}
		\end{itemize}
	\end{alertblock}
	\onslide<7->{
		\begin{block}{Caractérisation par le parcours infixe}
			Un arbre binaire est un {\sc abr} si et seulement si le parcours infixe fournit les clés dans l'ordre croissant.
		\end{block}}
\end{frame}


\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Exemple}
		\begin{center}
			\begin{tabular}{p{0.3cm}p{0.3cm}p{0.3cm}p{0.3cm}p{0.3cm}p{0.3cm}p{0.3cm}}
				                    &                     &                     & \circlenode{A}{{10}} &                      &                      & \phantom{0}\vspace{0.5cm} \\
				                    & \circlenode{B}{{6}} &                     &                      &                      & \circlenode{C}{{19}} & \phantom{0}\vspace{0.5cm} \\
				\circlenode{D}{{4}} &                     & \circlenode{E}{{?}} &                      & \circlenode{F}{{16}} &                      & \phantom{0}\vspace{0.5cm} \\
				                    & \circlenode{I}{{5}} &                     & \circlenode{G}{{13}} &                      & \circlenode{H}{{17}} &                           \\
				\ncline{->}{A}{B} \ncline{->}{A}{C} \ncline{->}{B}{D} \ncline{->}{B}{E} \ncline{->}{F}{G} \ncline{->}{F}{H} \ncline{C}{F} \ncline{D}{I}
			\end{tabular}\vspace{-0.5cm}
		\end{center}
		{\small
		\begin{itemize}
			\item<1-> Cet arbre est-il un {\sc abr} si la clé manquante est 2 ? 9 ? 12 ?
			\item<2-> On suppose que la clé manquante est 9. Proposer une nouvelle valeur pour le noeud de clé 16 de façon à ce que cet arbre reste un {\sc abr}.
			\item<3-> Proposer une valeur pour le noeud de clé 16 de façon à ce que cet arbre ne soit pas un {\sc abr}.
			\item<4-> Donner l'ordre des clés lors d'un parcours infixe.
		\end{itemize}}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{alertblock}{Insertion dans un {\sc abr}}
		Pour insérer une nouvelle valeur $u$ dans un {\sc abr} $A$ :
		\begin{itemize}
			\item<2-> Si $A$ est vide on renvoie $(\varnothing,u,\varnothing)$.
			\item<3-> Sinon $A = (g,v,d)$ et on insère dans $g$ si $u<v$ et dans $d$ sinon.
		\end{itemize}
	\end{alertblock}
	\onslide<4->
	{\begin{block}{Implémentation en OCaml}
		\inputpartOCaml{\SPATH/abr.ml}{}{}{70}{73}
	\end{block}}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Exercice}
		\begin{itemize}
			\item<1-> Dessiner l'arbre obtenu en partant de l'arbre vide puis en insérant dans cet ordre les valeurs :
				\begin{itemize}
					\item<2-> 2, 5, 7, 9 et 11
					\item<3-> 9, 5, 11, 2, 7
					\item<4-> 7, 5, 9, 2, 11
				\end{itemize}
				\item<5->En vous inspirant de la fonction d'insertion, écrire une fonction {\tt in\_abr} ({\tt abr -> int -> bool}) qui renvoie un booléen indiquant si la valeur passé en argument se trouve ou non dans l'{\sc abr}.
				\onslide<6->{\inputpartOCaml{\SPATH/abr.ml}{}{}{75}{79}}
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Complexité}
		La complexité des opérations d'insertion et de recherche dans un {\sc abr} est majorée par la hauteur $h$ de l'arbre. \onslide<2->\textcolor{gray}{ On descend d'un niveau dans l'arbre à chaque appel récursif et la profondeur d'un noeud est inférieure à $h$.}\\
		\onslide<3->{Or on sait que $ h+1 \leq n \leq 2^{h+1}-1$, et les deux bornes sont atteintes}
		\begin{itemize}
			\item<4-> Dans le cas d'un peigne ($n=h+1$) les opérations seront en $O(n)$.
			\item<5-> Dans le cas d'un arbre complet ($n=2^{h+1}-1$), les opérations seront en $O(\log(n))$.
		\end{itemize}
	\end{block}
	\onslide<6->{
		\begin{alertblock}{Définition}
			Soit $S$, un ensemble d'abres binaires. On dit que les arbres de $S$ sont \textcolor{blue}{équilibrés} s'il existe une constante $C$ telle que, pour tout arbre $s \in S$ :
			$$ h(s) \leq C \log(n(s))$$
		\end{alertblock}}
\end{frame}


\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Rotation d'un {\sc abr}}
		On considère l'{\sc abr} suivant où $u$ et $v$ sont les étiquettes des noeuds représentés et $t_1$, $t_2$, $t_3$ des arbres binaires :
		\onslide<2->{\begin{center}\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$v$}}{
					\pstree{\TCircle[radius=0.25cm]{$u$}}{
						\Tr{$t_1$}
						\Tr{$t_2$}}
					\Tr{$t_3$}
				}
			\end{center}}
		\onslide<3->{La \textcolor{blue}{rotation droite} de cet arbre, consiste à réorganiser les noeuds \textit{en conservant la propriété d'{\sc abr}} de la façon suivante :}
		\onslide<4->{
			\begin{center}
				\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$u$}}{
					\Tr{$t_1$}
					\pstree{\TCircle[radius=0.25cm]{$v$}}{
						\Tr{$t_2$}
						\Tr{$t_3$}
					}
				}
			\end{center}}
		\onslide<5->{De façon symétrique, la \textcolor{blue}{rotation gauche} consiste en partant de cet arbre à revenir à l'arbre initial.}
	\end{block}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Exemple}
		On considère l'arbre binaire suivant :
		\begin{center}\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\TCircle[radius=0.25cm]{$7$}}{
				\pstree{\TCircle[radius=0.25cm]{$3$}}{
					\TCircle[radius=0.25cm]{$2$}
					\pstree{\Tcircle[radius=0.25cm]{$5$}}
					{
						\TCircle[radius=0.25cm]{$4$}
						\TCircle[radius=0.25cm]{$6$}
					}
				}
				\TCircle[radius=0.25cm]{$9$}
			}
		\end{center}
		\begin{enumerate}
			\item<2-> Vérifier qu'il s'agit d'un {\sc abr}
			\item<3-> Montrer qu'un utilisant des rotations, on peut transformer cet arbre en un arbre binaire parfait.
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Correction}
		\begin{center}
			\pstree[arrows=->,treesep=0.7cm,levelsep=1cm]{\TCircle[radius=0.25cm]{$7$}}{
				\pstree{\TCircle[linecolor=BrickRed,linewidth=1pt,radius=0.25cm]{\textcolor{BrickRed}{$3$}} \nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{BrickRed}{$u$}}}{
					\TCircle[name=D,radius=0.25cm]{$\ 2\ $}
					\ncbox[linecolor=gray,nodesep=0.1,boxsize=0.3,linestyle=dashed]{D}{D}
					\nbput[labelsep=0]{\textcolor{gray}{$\scriptstyle t_1$}}
					\pstree{\Tcircle[linecolor=BrickRed,linewidth=1pt,radius=0.25cm]{\textcolor{BrickRed}{$5$}} \nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{BrickRed}{$v$}}}
					{
						\TCircle[name=Q,radius=0.25cm]{$4$}
						\ncbox[linecolor=gray,nodesep=0.1,boxsize=0.3,linestyle=dashed]{Q}{Q}
						\nbput[labelsep=0]{\textcolor{gray}{$\scriptstyle t_2$}}
						\TCircle[name=S,radius=0.25cm]{$6$}
						\ncbox[linecolor=gray,nodesep=0.1,boxsize=0.3,linestyle=dashed]{S}{S}
						\nbput[labelsep=0]{\textcolor{gray}{$\scriptstyle t_3$}}
					}
				}
				\TCircle[radius=0.25cm]{$9$} 
			} \hspace{1.5cm}
			\onslide<3->{
			\pstree[arrows=->,treesep=0.7cm,levelsep=1cm]{\TCircle[radius=0.25cm]{$7$}}{
				\pstree{\TCircle[linecolor=BrickRed,linewidth=1pt,radius=0.25cm]{\textcolor{BrickRed}{$5$}} \nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{BrickRed}{$v$}}}{
					\pstree{\Tcircle[linecolor=BrickRed,linewidth=1pt,radius=0.25cm]{\textcolor{BrickRed}{$3$}} \nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{BrickRed}{$u$}}}
					{
						\TCircle[name=D,radius=0.25cm]{$2$}
						\ncbox[linecolor=gray,nodesep=0.1,boxsize=0.3,linestyle=dashed]{D}{D}
						\nbput[labelsep=0]{\textcolor{gray}{$\scriptstyle t_1$}}
						\TCircle[name=Q,radius=0.25cm]{$4$}
						\ncbox[linecolor=gray,nodesep=0.1,boxsize=0.3,linestyle=dashed]{Q}{Q}
						\nbput[labelsep=0]{\textcolor{gray}{$\scriptstyle t_2$}}
					}
					\TCircle[name=S,radius=0.25cm]{$6$}
					\ncbox[linecolor=gray,nodesep=0.1,boxsize=0.3,linestyle=dashed]{S}{S}
					\nbput[labelsep=0]{\textcolor{gray}{$\scriptstyle t_3$}}
				}
				\TCircle[radius=0.25cm]{$9$} 
			}} \vspace{0.2cm}\\
			
			\vspace{1cm}
		\end{center}
	\end{exampleblock}
\end{frame}



\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Correction}
		\begin{center}
			\pstree[arrows=->,treesep=0.7cm,levelsep=1cm]{\TCircle[linecolor=BrickRed,linewidth=1pt,radius=0.25cm]{\textcolor{BrickRed}{$7$}} \nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{BrickRed}{$u$}}}{
				\pstree{\TCircle[linecolor=BrickRed,linewidth=1pt,radius=0.25cm]{\textcolor{BrickRed}{$5$}} \nput[labelsep=1 pt]{0}{\pssucc}{\textcolor{BrickRed}{$v$}}}{
						\pstree{\Tcircle[radius=0.25cm]{$3$}}
					{  
						\TCircle[name=D,radius=0.25cm]{$2$}
						\TCircle[name=Q,radius=0.25cm]{$4$}
						
					}
					\psframe[linecolor=gray,linestyle=dashed](0.9,0.25)(-1.1,-1.3)
					\nbput[labelsep=1.6cm]{\textcolor{gray}{$\scriptstyle t_1$}}
					\TCircle[name=S,radius=0.25cm]{$6$}
					\ncbox[linecolor=gray,nodesep=0.1,boxsize=0.3,linestyle=dashed]{S}{S}
					\nbput[labelsep=0]{\textcolor{gray}{$\scriptstyle t_2$}}
				}
				\TCircle[name=N,radius=0.25cm]{$9$}
				\ncbox[linecolor=gray,nodesep=0.1,boxsize=0.3,linestyle=dashed]{N}{N}
				\nbput[labelsep=0]{\textcolor{gray}{$\scriptstyle t_3$}}
			} \hspace{1.5cm}
			\onslide<2->
			{
				\pstree[arrows=->,treesep=0.7cm,levelsep=1cm]{\TCircle[radius=0.25cm]{$5$}}
						{
							\pstree[treesep=0.7cm,levelsep=1cm]{\TCircle[radius=0.25cm]{$3$}}{
								\TCircle[radius=0.25cm]{$2$}
								\TCircle[radius=0.25cm]{$4$}
							}
							\pstree[treesep=0.7cm,levelsep=1cm]{\TCircle[radius=0.25cm]{$7$}}{
								\TCircle[radius=0.25cm]{$6$}
								\TCircle[radius=0.25cm]{$9$}
							}
						}
			} \vspace{0.5cm}
		\end{center}
	\end{exampleblock}
	\onslide<3->{
		\begin{block}{Equilibrage d'un abre binaire}
			Les rotations droite et gauche sont les opérations permettant de maintenir un certain équilibre dans un {\sc abr}. Et donc de \textcolor{blue}{garantir une complexité logarithmique} des opérations usuelles. Parmi les nombreuses possibilités d'{\sc abr} équilibrés, nous allons détailler les \textcolor{BrickRed}{arbres rouge-noir}.
		\end{block}
	}
\end{frame}

\makess{Arbres rouge-noir}
\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{alertblock}{Définition des arbres rouge-noir}
		Un \textcolor{blue}{arbre rouge-noir} $t$ est un {\sc abr} (\textcolor{OliveGreen}{\ding{182}}), dans lequel chaque noeud porte une information de couleur (rouge ou noir), et ayant les deux propriétés suivantes :
		\begin{itemize}
			\item<1-> le père d'un noeud rouge est noir (\textcolor{OliveGreen}{\ding{183}}),
			\item<2-> le nombre de noeuds noirs le long d'un chemin de la racine à un sous arbre vide est toujours le même (\textcolor{OliveGreen}{\ding{184}}), on appellera \textcolor{blue}{hauteur noire} de $t$ et on notera $b(t)$ cette quantité .
		\end{itemize}
	\end{alertblock}
	\onslide<3->{
		\begin{exampleblock}{Exemples}
			\renewcommand{\arraystretch}{1.1}
			\begin{tabularx}{\textwidth}{Y|Y|Y}
			\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\NN{$8$}}{
				\pstree{\NR{$5$}}{
					\NN{$1$}
					\pstree{\NN{$6$}}
					{
						\NR{$3$}
						\NR{$7$}
					}
				}
				\NN{$9$}
			} & 
			\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\NN{$5$}}
						{
							\pstree[treesep=0.5cm,levelsep=0.7cm]{\NR{$2$}}{
								\NN{$1$}
								\pstree{\NR{$3$}}
								{
									\Tn{}
									\NN{$4$}
									
								}
							}
							\pstree[treesep=0.5cm,levelsep=0.7cm]{\NR{$8$}}{
								\NN{$7$}
								\Tn{}
							}
						}
			& 
			\pstree[arrows=->,treesep=0.5cm,levelsep=0.7cm]{\NN{$7$}}
						{
							\pstree[treesep=0.5cm,levelsep=0.7cm]{\NN{$2$}}{
								\Tn{}
								\Tn{}
							}
							\pstree[treesep=0.5cm,levelsep=0.7cm]{\NR{$8$}}{
								\NN{$6$}
								\NN{9}
							}
						}
			\\
			\leavevmode\onslide<3->{\textcolor{OliveGreen}{\small \ding{182} \faCheck \quad \ding{183} \faCheck  \quad \ding{184} \faCheck}} & \leavevmode\onslide<4->{\textcolor{OliveGreen}{\small \ding{182} \faCheck \quad  \ding{183}} \textcolor{BrickRed}{\small \faTimesCircle} \textcolor{OliveGreen}{\small \quad \ding{184} \faCheck}} & \leavevmode\onslide<5->{\textcolor{OliveGreen}{\small \ding{182}}  \textcolor{BrickRed}{\small \faTimesCircle} \textcolor{OliveGreen}{\small \quad\ding{183} \faTimesCircle \quad \ding{184} \faCheck}}\\
		\end{tabularx}
		
		\end{exampleblock}
	}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Proriété d'équilibre des arbres rouge-noirs}
		Pour tout arbre rouge noir $t$ :
		\begin{itemize}
			\item<2-> $h(t) \leqslant 2b(t)$ 
			\item<3-> $2^{b(t)} \leqslant n(t) +1$
		\end{itemize}
		\onslide<4->{Conséquences : les arbres rouge-noir forment un ensemble d'arbres équilibrés.}
	\end{block}
	\onslide<5->{\begin{block}{Implémentation}
		Une implémentation en OCaml sera vue en TP, les opérations d'insertion et de suppression sont difficiles et reposent sur les rotations droite et gauche des {\sc abr}.
	\end{block}}
\end{frame}



\makess{Tas et files de priorité}
\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Definition}
		Une file de priorité est une structure de données, dans laquelle :
		\begin{itemize}
		\item<2-> chaque élément enfilé possède une priorité.
		\item<3-> lorsqu'on défile un élément, on enlève l'élément le plus prioritaire (et donc pas forcément le premier enfilé comme dans une file classique).
		\end{itemize}
	\end{block}
	\onslide<4->{
	\begin{exampleblock}{Exercice}
		Déterminer les complexités des opérations enfiler et défiler si on implémente une file de priorité à l'aide d'une liste chainée.
	\end{exampleblock}}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{alertblock}{Structure de tas}
		Un arbre binaire, dont les éléments sont comparables, possède la structure de \textcolor{blue}{tas} si et seulement si :
		\begin{itemize}
			\item<2-> il est vide ou
			\item<3-> il est de la forme $N(g,v,d)$, avec $g$ et $d$ possédant la structure de tas et $v$ est inférieur à tous les éléments de $g$ et de $d$. 
		\end{itemize}
	\end{alertblock}
\end{frame}


\end{document}