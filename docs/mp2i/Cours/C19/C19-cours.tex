\PassOptionsToPackage{dvipsnames,table}{xcolor}
\documentclass[10pt]{beamer}
\usepackage{Cours}

\begin{document}


\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/MacrosCours.tex}}

% Numéro et titre de chapitre
\setcounter{numchap}{19}
\newcommand{\Ctitle}{\cnum {Algorithmes des textes}}
\newcommand{\SPATH}{/home/fenarius/Travail/Cours/cpge-info/docs/mp2i/files/C\thenumchap/}
\newcommand{\tv}{\textvisiblespace}

\makess{Position du problème}
\begin{frame}{\Ctitle}{\stitle}
	\begin{block}{Définitions et notations}
		On s'intéresse au problème de la recherche d'une chaîne de caractères appelée \textcolor{blue}{motif} dans une autre chaîne de caractères appelée \textcolor{blue}{texte}. Plus précisement, on veut lister toutes les occurences (par leur position) du motif dans le texte. \\
		On notera :
		\begin{itemize}
			\item<2-> $m$ le motif et $l_m$ sa longueur
			\item<3-> $t$ le texte et $l_t$ sa longueur
		\end{itemize}
		\onslide<4->{D'autre part, parfois le problème se réduira à déterminer si $m$ est présent ou non dans $t$, ou encore on cherchera uniquement la première occurence.}
	\end{block}
	\onslide<5->{\begin{exampleblock}{Exemple}
			\onslide<5->{La recherche du motif $m$=\textcolor{OliveGreen}{\tt exe} ($l_m=3$) dans le texte $t=$\textcolor{gray}{\tt un excellent exemple et un exercice extraordinaire} ($l_t=50$) doit produire la liste d'occurrences : [13; 27].\\}
			\onslide<6->{
				\renewcommand*{\arraystretch}{0.5}
				\begin{tabular}{>{\tt}l@{}l@{}l@{}l@{}r}
					\textcolor{gray}{{un}\tv{}excellent\tv{}} & \textcolor{OliveGreen}{e}        & \textcolor{OliveGreen}{xe}\textcolor{gray}{mple\tv{}et\tv{}un\tv{}} & \textcolor{OliveGreen}{e}        & \textcolor{OliveGreen}{xe}\textcolor{gray}{rcice\tv{}extraordinaire} \\
					\textcolor{gray}{\tiny 0}                 & \textcolor{OliveGreen}{\tiny 13} &                                                                     & \textcolor{OliveGreen}{\tiny 27} & \textcolor{gray}{\tiny 49}                                           \\
				\end{tabular}
			}
		\end{exampleblock}}
\end{frame}


\makess{Recherche naïve}
\begin{frame}{\Ctitle}{\stitle}
	\begin{block}{Recherche naïve}
		Pour recherche si un motif $m$ se trouve dans un  texte $t$, on peut :
		\begin{enumerate}
			\item<1-> parcourir chaque caractère de $t$ jusqu'à celui d'indice \alt<2->{$l_t-l_m$}{\textcolor{red}{?}} inclus (indice de la dernière occurrence possible) :\\
			\begin{tabular}{l|c|c|c|c|}
				\cline{2-5}
				indice dans le texte &	0 & \dots & \alt<2->{$l_t-l_m$}{\textcolor{red}{?}} & $l_t-1$ \\
				\cline{2-5}
				\multicolumn{1}{c}{indice dans le motif} & \multicolumn{2}{c|}{} & 0 & $l_m-1$ \\
				\cline{4-5}
			\end{tabular}
			\item<3-> si le caractère correspond au premier caractère du motif $m$,  alors on avance dans le motif tant que les caractères coïncident.
			\item<4-> si on atteint la fin du motif, alors $m$ se trouve dans $t$. Sinon on passe au caractère suivant de $t$.
		\end{enumerate}
	\end{block}
	\onslide<5->{
	\begin{exampleblock}{Exemple}
		\href{https://boyer-moore.codekodo.net/recherche_naive.php}{Visualisation en ligne du fonctionnement de l'algorithme }
	\end{exampleblock}}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Implémentation en OCaml}
		On renvoie la \textit{liste} de toutes les occurrences : {\tt naive : string -> string -> int list}
		\onslide<2->{\inputpartOCaml{\SPATH/naive.ml}{}{}{3}{14}}
	\end{block}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Implémentation en OCaml}
		Dans le cas où on teste simplement la présence, on peut provoquer une sortie anticipée de la boucle \mintinline{ocaml}{for} à l'aide d'une exception.
		\onslide<2->{\inputpartOCaml{\SPATH/naive.ml}{}{\small}{16}{28}}
	\end{block}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{block}{Coût de la recherche simple}
		En notant $l_m$ la longueur du motif et $l_t$ celle de la chaine :
		\begin{itemize}
			\item<2-> La boucle \mintinline{ocaml}{for} est parcourue au plus $l_t-l_m+1$ fois
			\item<3-> Pour chacun de ces parcours, la boucle \mintinline{ocaml}{while} interne est parcourue au plus $l_m$ fois
		\end{itemize}
		\onslide<4->{Au plus, l'algorithme effectue donc $l_m(l_t-l_m+1)$ comparaisons.}
	\end{block}
	\onslide<5->{
	\begin{exampleblock}{Exemple}
		Combien de comparaisons seront nécessaires si on recherche le motif \pmc{bbbbbbbbba} (neuf fois le caractère \pmc{b} suivi d'un \pmc{a}) dans une chaine contenant un million de \pmc{b} ?
	\end{exampleblock}}
\end{frame}

\makess{Algorithme de Boyer-Moore}
\begin{frame}{\Ctitle}{\stitle}
	\begin{block}{Accélération de la recherche}
		Supposons qu'on recherche le motif {\tt extra} dans la chaine {\tt un excellent exemple et un exercice extraordinaire}. La comparaison naïve ci-dessus commence par :\\
		\onslide<2->{
			\begin{tabular}{|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|}
				\hline
				u                                  & n                     &   & e & x & c & e & l & l & e & n & t \\
				\hline
				\multicolumn{1}{c}{$\updownarrow$} & \multicolumn{11}{c}{}                                         \\
				\hline
				e                                  & x                     & t & r & a &   &   &   &   &   &   &   \\
				\hline
			\end{tabular}}\\
		\onslide<3->{Deux idées vont permettre d'accélérer la recherche :}
		\begin{itemize}
			\item<4-> Commencer par la fin du motif.
			\item<5-> Prétraiter le motif de façon à éviter des comparaisons inutiles.
		\end{itemize}
	\end{block}
\end{frame}


\begin{frame}{\Ctitle}{\stitle}
	\begin{block}{Accélération de la recherche}
		Dans l'exemple ci-dessus cela donne : \\
		\onslide<2->{
			\begin{tabular}{|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|>{\tt}c|}
				\hline
				u                    & n                                  &                      & e &\cellcolor{OliveGreen!30}{x} & c & e & l & l & e & n & t \\
				\hline
				\multicolumn{4}{c}{} & \multicolumn{1}{c}{$\updownarrow$} & \multicolumn{6}{c}{}                                     \\
				\hline
				e                    & \cellcolor{OliveGreen!30}{x}                                  & t                    & r & \cellcolor{BrickRed!30}{a} &   &   &   &   &   &   &   \\
				\hline
			\end{tabular}}\\
		\onslide<3->{On peut directement décaler le motif de 3 emplacements car le dernier {\tt x} du motif se trouve à 3 emplacements de la fin du motif.\\}
		\onslide<4->{
			\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
				\hline
				u                    & n                                  &                      & e & x & c & e & \cellcolor{OliveGreen!30}{l} & l & e & n & t \\
				\hline
				\multicolumn{7}{c}{} & \multicolumn{1}{c}{$\updownarrow$} & \multicolumn{3}{c}{}                                     \\
				\hline
				                     &                                    &                      & e & x & t & r & \cellcolor{BrickRed!30}{a} &   &   &   &   \\
				\hline
			\end{tabular}\\}
		\onslide<5->{Cette fois, le {\tt l} ne se trouve pas dans le motif, on peut donc décaler de la longueur du motif. Et la recherche s'arrête en ayant effectué seulement deux comparaisons.\\}
	\end{block}
		\onslide<6->{
			\begin{exampleblock}{Visualisation en ligne}
			\href{https://boyer-moore.codekodo.net/recherche_boyer.php}{Visualisation en ligne du fonctionnement de l'algorithme accéléré}
			\end{exampleblock}}
\end{frame}


\begin{frame}{\Ctitle}{\stitle}
	\begin{block}{Algorithme de Boyer-Moore-Hoorspool}
		\begin{itemize}
		\item<1-> La première phase consiste en un prétraitement du motif, afin de construire une \textcolor{blue}{fonction de décalage} qui indique pour chaque caractère \textcolor{blue}{\tt c}:
		\begin{itemize}
			\item<2-> Si \textcolor{blue}{\tt c} est dans le motif, Le nombre de caractères entre la \textit{dernière occurrence} de \textcolor{blue}{\tt c} et la fin du motif (l'avant dernière si \textcolor{blue}{\tt c} est le dernier caractère.)
			\item<3-> Sinon la longueur du motif
		\end{itemize}
		\item<4-> Ensuite on effectue une recherche en partant de la fin du motif en cas de non correspondance, on décale de la valeur fournie par la fonction de décalage.
	\end{itemize}
	\end{block}
	\onslide<5->{
		\begin{exampleblock}{Exemple}
			\begin{enumerate}
				\item<6-> Construire la table de décalage du motif "\textcolor{gray}{\tt toto}"
				\item<7-> Simuler le fonction de l'algorithme de Boyer-Moore-Hoorspool pour recherche ce motif dans le chaine "\textcolor{gray}{\tt zéro plus zéro = la tête à toto}"
			\end{enumerate}
			
		\end{exampleblock}
	}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Exercices}
		\begin{enumerate}
		\item Ecrire en C, une fonction de signature \mintinline{c}{int *cree_decalage(char *motif)} qui renvoie la table de décalage d'un motif. On représentera un caractère par son code (donc un entier) et on suppose qu'on utilise la table {\sc ascii} standard qui contient 127 caractères. 
		\item Simuler la recherche de \textcolor{gray}{\tt abb} dans le texte \textcolor{gray}{\tt b...b} ($t$ fois la lettre b) avec l'algorithme de Boyer-Mooore. Donner le nombre de comparaisons effectué et comparer avec la recherche naïve.
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{block}{Implémentation en C}
		Fonction qui renvoie {\tt true} si {\tt motif} est présent dans {\tt texte} et {\tt false} sinon.
		\inputpartC{\SPATH/bmh.c}{}{\small}{50}{63}
	\end{block}
\end{frame}

\makess{Algorithme de Rabin-Karp}
\begin{frame}{\Ctitle}{\stitle}
	\begin{block}{Principe}
		L'idée de l'algorithme est d'utiliser une fonction de hachage $h$ sur les chaines de caractères, et de comparer les hash du motif $h(m)$ avec le hash du texte commençant à l'indice \textcolor{blue}{\tt i} et de longueur $l_m$ pour {\textcolor{blue}{\tt i}} de 0 à $l_t-l_m$. On effectue la comparaison caractère par caractère seulement dans le cas où les deux hash sont égaux.
	\end{block}
\end{frame}
\end{document}