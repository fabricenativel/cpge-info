\PassOptionsToPackage{dvipsnames,table}{xcolor}
\documentclass[10pt]{beamer}
\usepackage{Cours}

\begin{document}


\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/MacrosCours.tex}}

% Numéro et titre de chapitre
\setcounter{numchap}{15}
\newcommand{\Ctitle}{\cnum {Décompostion en sous problèmes}}
\newcommand{\SPATH}{/home/fenarius/Travail/Cours/cpge-info/docs/mp2i/files/C\thenumchap/}


\makess{Rappel : mémoïsation}
\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Exemple}
		\begin{enumerate}
			\item<1-> Ecrire une fonction récursive \textit{naïve} qui prend en argument un entier $n$ et renvoie le $n$ième terme de la suite de Fibonacci définie par :
				$\left\{ \begin{array}{lll}
						f_0   & = & 0,                                                  \\
						f_1   & = & 1,                                                  \\
						f_{n} & = & f_{n-1}+f_{n-2} \mathrm{\ \ pour\ tout\ \ } n\geq2.\end{array} \right.$
			\item<2-> Tracer le graphe des appels récursifs de cette fonction pour $n=5$
			\item<3-> Commenter
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Correction question 1}
		\inputpython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/fibo_rec.py}{}{\footnotesize}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Correction questions 2}
		\begin{center}
			\psset{levelsep=1cm,treesep=0.2cm,linecolor=OliveGreen,linewidth=0.6pt}
			\pstree{\Toval{\tiny \tt fibo(5)}}{
				\pstree{\Toval{\tiny \tt fibo(4)}}{
					\pstree{\Toval{\tiny \tt  fibo(3)}}{
						\pstree{\Toval{\textcolor{BrickRed}{\tt \tiny fibo(2)}}}{\Toval{\tt \tiny fibo(1)} \Toval{\tiny \tt  fibo(0)}}
						\Toval{\tiny \tt  fibo(1)}}
					\pstree{\Toval{\textcolor{BrickRed}{\tt \tiny fibo(2)}}}{\Toval{\tiny  \tt fibo(1)} \Toval{\tiny \tt  fibo(0)}}
				}
				\pstree{\Toval{\tiny \tt fibo(3)}}{
					\pstree{\Toval{\textcolor{BrickRed}{\tt \tiny fibo(2)}}}{\Toval{\tiny \tt  fibo(1)} \Toval{\tiny \tt  fibo(0)}}
					\Toval{\tiny \tt  fibo(1)}}
			}
		\end{center}
	\end{exampleblock}
\end{frame}


\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Correction questions 3}
		\begin{center}
			\psset{levelsep=1cm,treesep=0.2cm,linecolor=OliveGreen,linewidth=0.6pt}
			\pstree{\Toval{\tiny \tt fibo(5)}}{
				\pstree{\Toval{\tiny \tt fibo(4)}}{
					\pstree{\Toval{\tiny \tt  fibo(3)}}{
						\pstree{\Toval{\textcolor{BrickRed}{\tt \tiny fibo(2)}}}{\Toval{\tt \tiny fibo(1)} \Toval{\tiny \tt  fibo(0)}}
						\Toval{\tiny \tt  fibo(1)}}
					\pstree{\Toval{\textcolor{BrickRed}{\tt \tiny fibo(2)}}}{\Toval{\tiny  \tt fibo(1)} \Toval{\tiny \tt  fibo(0)}}
				}
				\pstree{\Toval{\tiny \tt fibo(3)}}{
					\pstree{\Toval{\textcolor{BrickRed}{\tt \tiny fibo(2)}}}{\Toval{\tiny \tt  fibo(1)} \Toval{\tiny \tt  fibo(0)}}
					\Toval{\tiny \tt  fibo(1)}}
			}
		\end{center} \medskip
		{\small On calcule à plusieurs reprises les \textit{mêmes valeurs}, ici par exemple \textcolor{BrickRed}{\tt fibo(2)} est calculé à trois reprises.}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Mémoïsation}
		\begin{itemize}
			\item<1-> La \textcolor{blue}{mémoïsation} consiste à stocker dans une structure de données les valeurs renvoyées par une fonction afin de ne pas les recalculer lors des appels identiques suivant.\\
			\item<2-> En Python, on utilise un dictionnaire dont les clés sont les arguments de la fonction et les valeurs les résultats de la fonction.
		\end{itemize}
	\end{alertblock}
	\begin{exampleblock}{Exemple}
		\onslide<3->{Par exemple, si on stocke dans un dictionnaire la valeur de {\tt fibo(2)} (clé : 2, valeur: 1), on n'a plus besoin de la recalculer lors des futurs appels.}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{exampleblock}{Fibonnaci avec mémoïsation}
		\inputpython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/fibo_rec_memo.py}{}{\footnotesize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Remarque}
		En python, la mémoïsation peut-être effectuée de façon automatique à l'aide du décorateur \kw{lru\_cache} du module \kw{ functools}. Après importation, on écrira simplement \kw{@lru\_cache} avant la définition de la fonction dont on veut mémoïser les appels.
	\end{block}
	\onslide<2->{
		\begin{exampleblock}{Fibonacci mémoïsation automatique}
			\inputpython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/fibo_rec_memo2.py}{}{\footnotesize}
		\end{exampleblock}}
\end{frame}

\makess{Programmation dynamique : exemple introductif}
\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Position du problème}
		\onslide<1->{\small On considère une barre de métal de longueur entière 12 et pouvant être découpée en morceaux de longueurs entières ayant chacun un prix comme indiqué ci-dessous :
			\begin{center}
				\begin{tabular}{|l|p{0.2cm}|p{0.2cm}|p{0.2cm}|p{0.2cm}|p{0.2cm}|p{0.2cm}|p{0.2cm}|p{0.2cm}|p{0.2cm}|p{0.2cm}|p{0.2cm}|p{0.2cm}|}
					\hline
					longueur & 1 & 2 & 3 & 4 & 5  & 6  & 7  & 8  & 9  & 10 & 11 & 12 \\
					\hline
					prix     & 2 & 4 & 7 & 8 & 12 & 14 & 18 & 23 & 24 & 25 & 26 & 31 \\
					\hline
				\end{tabular}
			\end{center}}
		\onslide<2->{\small Le prix de vente des différents morceaux varie donc suivant la découpe utilisée, par exemples :
			la découpe $(2, 4, 6)$ a un prix de vente de $4+8+14=26$, tandis que la découpe $(7, 5)$ a un prix de vente de $18+12=30$\\}
		\onslide<3->\textcolor{blue}{\small Le but du problème est de trouver la valeur maximale des découpes possibles.\\}
		\onslide<4->{\small On note $N$ la longueur de la barre, $(v_i)_{0\leq i \leq N}$, la valeur maximale de la découpe d'une barre de taille $i$ et $(p_i)_{0 \leq i \leq N}$ le prix d'un morceaux de longueur $i$.}
		\begin{enumerate}
			\item<5-> Donner les valeurs de $v_0$ et $v_1$.
			\item<6-> Etablir une relation de récurrence liant les $(v_i)_{0\leq i \leq N}$.
			\item<7-> En déduire une fonction Python récursive calculant la valeur de la découpe maximale.
			\item<8-> Utiliser la mémoïsation dans cette fonction.
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Résolution}
		\begin{enumerate}
			\item<1-> \textcolor{OliveGreen}{$v_0=0$ et $v_1=1$}
			\item<2-> \textcolor{OliveGreen}{En supposant qu'on connaisse les valeurs maximales de découpe pour les tailles inférieurs $n$, la découpe maximale pour la taille $n$ s'en déduit en prenant le maximum parmi les découpes maximales d'une barre de longueur $k \leq n-1$  et d'un morceau de taille $n-k$, c'est à dire :
					$v_n = \max\left\{ v_k + p_{n-k},  0 \leq k \leq n-1\right\}$}
			\item<3-> \textcolor{OliveGreen}{Programme Python :}
				\inputpython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/decoupe.py}{}{\scriptsize}
				\onslide<4->\textcolor{OliveGreen}{Le programme affiche 32.}
		\end{enumerate}
	\end{exampleblock}
\end{frame}


\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Version avec mémoïsation}
		\inputpython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/decoupe_memo.py}{}{\scriptsize}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Calcul de bas en haut (\textit{bottom up})}
		\onslide<1->{La mémoïsation construit la solution de façon "descendante", on lance les appels récursif sur les plus grandes valeurs de taille de la barre. Une autre stratégie dite \textcolor{blue}{ascendante} ou \textcolor{blue}{de bas en haut (\textit{bottom up})} consiste à construire la solution en partant des instances les plus petites du problème.\\}
		\onslide<2->{Pour la découpe de la barre on part donc des valeurs connues $v_0$ et $v_1$ et on construit $v_2$ puis $v_3$, en utilisant la relation de récurrence $v_n = \max\left\{ v_k + p_{n-k},  0 \leq k \leq n-1\right\}$}\\
		\onslide<3->{Ce qui se traduit en Python par une solution \textcolor{blue}{itérative} :}
		\onslide<4->{\inputpython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/decoupe_iter.py}{}{\footnotesize}}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Construction d'une solution}
		On a pour le moment déterminé la valeur maximale de la découpe, mais pas la découpe elle-même. D'autre part, plusieurs découpes différentes peuvent avoir cette même valeur maximale. Pour rechercher \textit{une} découpe de valeur maximale, on peut par exemple :
		\begin{itemize}
			\item<1-> construire le tableau $(v_k)_{0\leq k \leq\N}$  et l'utiliser afin d'en déduire la découpe. \\
				\onslide<2->{\textcolor{gray}{\small Par exemple, si $v_{12} = v_8 + p_4$, cela signifie que pour avoir la valeur maximale de la découpe d'une barre de taille 12, une possibilité est d'utiliser une découpe  maximale d'une barre de taille 8 et un morceau de taille 4. En remontant ainsi de proche en proche, on obtient une découpe maximale possible}}
			\item<3-> Modifier notre fonction afin qu'elle renvoie la découpe maximale et non pas la valeur de cette découpe. \\
		\end{itemize}
		\onslide<4->{Ces deux possibilités seront abordées en TP.}
	\end{exampleblock}
\end{frame}


\makess{Programmation dynamique}
\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Principes généraux}
		La programmation dynamique s'applique généralement à la résolution d'un problème d'optimisation vérifiant les conditions suivantes :
		\begin{enumerate}
			\item<2-> \textcolor{blue}{Sous structure optimale} : ce problème peut-être résolu à partir de problèmes similaires mais plus petits \\
				\onslide<3->\textcolor{gray}{\small La découpe maximale d'une barre de taille $N$ s'obtient comme découpe maximale  d'une barre de taille strictement inférieure $k$ et d'un morceau de taille $N-k$.}
				\item<4->\textcolor{blue}{Chevauchement de sous problème} : une solution récursive produit des appels identiques. Pour pallier ce problème, on utilise la mémoïsation dans les solutions récursives.\\
				\onslide<5->\textcolor{gray}{\small Pour rechercher la découpe maximale d'un barre de taille 5, on est amené à chercher celle d'une barre de taille 4,3,2,1. Et pour chercher celle d'une barre de taille 4, on fera de nouveau appel à celle d'une barre de taille 3,2,1 ...}
		\end{enumerate}
		\onslide<6->{\textcolor{BrickRed}{\small \important} L'étape cruciale est de déterminer les relations de récurrence entre les différentes instances du problème. Les différentes méthodes d'implémentation relèvent du choix du programmeur.}
	\end{alertblock}
\end{frame}


\makess{Exemple résolu : plus longue sous séquence commune}
\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Position du problème}
		On considère deux chaines de caractères $u$ et $v$ de longueurs respectives $n$ et $m$. On cherche à déterminer la longueur de leur \textcolor{blue}{p}lus \textcolor{blue}{l}ongue \textcolor{blue}{s}ous \textcolor{blue}{s}équence \textcolor{blue}{c}ommune (\textcolor{blue}{plssc}), c'est à dire la chaine $w$ telle que :
		\begin{itemize}
			\item<2-> $w$ est une sous séquence (c'est à dire une suite extraite) de $u$,
			\item<3-> $w$ est une sous séquence de $w$,
			\item<4-> $w$ est de longueur maximale.
		\end{itemize}
		\onslide<5->{Par exemple,  $u$="{\sc programmation}" et $v$="{\sc dynamique}" ont comme sous séquence commune "{\sc ami}" (et c'est la plus longue)}
		\begin{itemize}
			\item<6-> {\sc progr\textcolor{BrickRed}{a}m\textcolor{BrickRed}{m}at\textcolor{BrickRed}{i}on}
			\item<7-> {\sc dyn\textcolor{BrickRed}{ami}que}
		\end{itemize}
		\onslide<8->{Donc ici, la longueur de la plssc est 3.}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Résolution}
		On cherche les relations de récurrence entre des instances du sous-problème. Pour cela on note $u_i$ ($0\leq i \leq n$) la chaine composée des $i$ premiers caractères de $u$, et $v_j$ ($0\leq j \leq m$) celle composée des $j$ premiers caractères de $v$. Et on note $\mathrm{lplssc}(u_i,v_j)$ la longueur de la plssc de $u_i$ et de $v_j$.
		\begin{itemize}
			\item<2->{Si $u[i] = v[j]$ alors, quelle est la relation entre $\mathrm{lplssc}(u_i,v_j)$ et $\mathrm{lplssc}(u_{i-1},v_{j-1})$ ? \\}
			\onslide<5->{\textcolor{OliveGreen}{$\mathrm{lplssc}(u_i,v_j) = 1 + \mathrm{lplssc}(u_{i-1},v_{j-1})$}}
			\item<3->{Sinon, exprimer $\mathrm{plssc}(u_i,v_j)$ en fonction de  $\mathrm{plssc}(u_{i},v_{j-1})$  et $\mathrm{plssc}(u_{i-1},v_j)$}
			\onslide<6->{\textcolor{OliveGreen}{$\mathrm{lplssc}(u_i,v_j) = \max\left(\mathrm{lplssc}(u_{i},v_{j-1}) ,\mathrm{lplssc}(u_{i-1},v_{j})\right)$}}
			\item<4->{Déterminer les cas de base (ceux où $u$ et $v$ sont des chaines vides notés ""):\\}
			\onslide<7->{\textcolor{OliveGreen}{$\mathrm{lplssc}(u_{i},"") = 0$} \\
				\textcolor{OliveGreen}{$\mathrm{lplssc}("",v_j) = 0$} }
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Programme Python pour plssc}
		{\inputpartPython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/plssc.py}{}{\footnotesize}{1}{9}}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Construction effective d'une solution}
		On peut modifier notre programme donnant la longueur de la plssc afin d'obtenir la plssc :
		\begin{itemize}
			\item<1-> {\small Si le dernier caractère est commun, il fait partie de la plssc et on relance la récursion sur les parties restantes de chaque chaîne}
			\item<2-> {\small Sinon on regarde quel appel produit la plssc et on renvoie le résultat de cet appel}
		\end{itemize}
		\onslide<3->{\inputpartPython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/plssc.py}{}{\footnotesize}{13}{22}}
	\end{exampleblock}
\end{frame}

\makess{Exemple résolu : rendu de monnaie}
\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Position du problème}
		On dispose d'un \textit{système monétaire} c'est à dire d'un ensemble de valeurs possibles pour les pièces et les billets. Le problème du rendu de monnaie consiste à déterminer le nombre minimal de pièces à utiliser pour former une somme donnée. \\
		\onslide<2->{Par exemple si le système monétaire est $\{ 5, 4, 3, 1 \}$ et la somme 7,}
		\onslide<3->{alors on peut utiliser au minimum 2 pièces ($4+3$).}\\
		\onslide<5->{\textcolor{blue}{\small \rappel \; Rappel : }{\textcolor{gray}{ l'algorithme glouton qui consiste à rendre à tout moment la pièce de plus forte valeur possible ne fournit pas toujours la solution optimale. Ici, on obtiendrait $5, 1, 1$ et donc 3 pièces.}}}
		\begin{enumerate}
			\item<6-> Ecrire une relation de récurrence entre les différentes instances du problème en donnant les solutions des cas de base.
			\item<7-> Ecrire un programme python permettant de répondre au problème.
			\item<8-> Construire la liste effective des pièces à rendre.
		\end{enumerate}
	\end{exampleblock}
\end{frame}


\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Résolution}
		\begin{enumerate}
			\item<2->\textcolor{OliveGreen}{On note} :
			\begin{itemize}
				\item<3->\textcolor{OliveGreen}{$S$ la somme à rendre,}
				\item<4->\textcolor{OliveGreen}{$(p_i)_{0 \leq i \leq n}$ les valeurs des pièces rangées dans l'ordre décroissant}
				\item<5->\textcolor{OliveGreen}{$m(S,k)$ le nombre minimal de pièce pour rendre la somme~$S$ en utilisant les pièces à partir de la $k$-ième.}
			\end{itemize}
			\onslide<6->\textcolor{OliveGreen}{Avec ces notations, on doit donc trouver $m(S,0)$ et on dispose des relations suivantes :}
			\onslide<7->{\textcolor{OliveGreen}{$\left\{ \begin{array}{lll}
							m(0,k)   & = & 0 \text{ pour tout } 0\leq k \leq n,                         \\
							m(S,n+1) & = & +\infty                                                      \\
							m(S,k)   & = & m(S,k+1)    \text{ si }  S<p_k,                              \\
							m(S,k)   & = & min\left\{ 1 + m(S-p_k,k), m(S,k+1) \text{  }\right\} sinon.\end{array} \right.$}\medskip \\}
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Résolution}
		\begin{enumerate}
			\addtocounter{enumi}{1}
			\item Programme Python (avec mémoïsation dans le dictionnaire \kw{memo})
			      {\inputpartPython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/rm.py}{}{\footnotesize}{3}{13}}
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Résolution}
		\begin{enumerate}
			\addtocounter{enumi}{2}
			\item \textcolor{OliveGreen}{Pour construire la liste des pièces à rendre, on peut partir des valeurs de $m(S,k)$ : \\}
			      \renewcommand{\arraystretch}{1.3}
			      \begin{tabular}{|c|c|c|c|c|c|c|}
				      \hline
				      \backslashbox{$S$}{$k$} & $0$                          & $1$                          & $2$                          & $3$                          & $4$                        \\
				      \hline
				      $0$                     & \textcolor{gray}{0}          & \textcolor{gray}{0}          & \textcolor{gray}{0}          & \textcolor{gray}{0}          & \textcolor{gray}{$\infty$} \\
				      $1$                     & \leavevmode\onslide<2->{$1$} & \leavevmode\onslide<2->{$1$} & \leavevmode\onslide<2->{$1$} & \leavevmode\onslide<2->{$1$} & \textcolor{gray}{$\infty$} \\
				      $2$                     & \leavevmode\onslide<3->{$2$} & \leavevmode\onslide<3->{$2$} & \leavevmode\onslide<3->{$2$} & \leavevmode\onslide<3->{$2$} & \textcolor{gray}{$\infty$} \\
				      $3$                     & \leavevmode\onslide<4->{$1$} & \leavevmode\onslide<4->{$1$} & \leavevmode\onslide<4->{$1$} & \leavevmode\onslide<4->{$3$} & \textcolor{gray}{$\infty$} \\
				      $4$                     & \leavevmode\onslide<5->{$1$} & \leavevmode\onslide<5->{$1$} & \leavevmode\onslide<5->{$2$} & \leavevmode\onslide<5->{$4$} & \textcolor{gray}{$\infty$} \\
				      $5$                     & \leavevmode\onslide<6->{$1$} & \leavevmode\onslide<6->{$2$} & \leavevmode\onslide<6->{$3$} & \leavevmode\onslide<6->{$5$} & \textcolor{gray}{$\infty$} \\
				      $6$                     & \leavevmode\onslide<7->{$2$} & \leavevmode\onslide<7->{$2$} & \leavevmode\onslide<7->{$2$} & \leavevmode\onslide<7->{$6$} & \textcolor{gray}{$\infty$} \\
				      $7$                     & \leavevmode\onslide<8->{$2$} & \leavevmode\onslide<8->{$2$} & \leavevmode\onslide<8->{$3$} & \leavevmode\onslide<8->{$7$} & \textcolor{gray}{$\infty$} \\
				      \hline
			      \end{tabular} \quad \textcolor{blue}{$\boxed{p_0=5, p_1=4, p_2=3, p_3 =1}$}
		\end{enumerate}
	\end{exampleblock}
\end{frame}


\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Résolution}
		\begin{enumerate}
			\addtocounter{enumi}{2}
			\item \textcolor{OliveGreen}{Pour construire la liste des pièces à rendre, on peut partir des valeurs de $m(S,k)$ : \\}
			      \renewcommand{\arraystretch}{1.3}
			      \begin{tabular}{|c|c|c|c|c|c|c|}
				      \hline
				      \backslashbox{$S$}{$k$} & $0$                 & \alt<2->{\textcolor{blue}{$\boxed{1}$}}{$1$} & \alt<5->{\textcolor{blue}{$\boxed{2}$}}{$2$}     & $3$                 & $4$                        \\
				      \hline
				      $0$                     & \textcolor{gray}{0} & \textcolor{gray}{0}                          & \textcolor{gray}{0}                              & \textcolor{gray}{0} & \textcolor{gray}{$\infty$} \\
				      $1$                     & $1$                 & $1$                                          & $1$                                              & $1$                 & \textcolor{gray}{$\infty$} \\
				      $2$                     & $2$                 & $2$                                          & $2$                                              & $2$                 & \textcolor{gray}{$\infty$} \\
				      \rnode{A}{$3$}          & $1$                 & $1$                                          & \alt<4->{\textcolor{BrickRed}{$\boxed{1}$}}{$1$} & $3$                 & \textcolor{gray}{$\infty$} \\
				      $4$                     & $1$                 & $1$                                          & $2$                                              & $4$                 & \textcolor{gray}{$\infty$} \\
				      $5$                     & $1$                 & $2$                                          & $3$                                              & $5$                 & \textcolor{gray}{$\infty$} \\
				      $6$                     & $2$                 & $2$                                          & $2$                                              & $6$                 & \textcolor{gray}{$\infty$} \\
				      \rnode{D}{$7$}          & $2$                 & \textcolor{BrickRed}{$\boxed{2}$}            & $3$                                              & $7$                 & \textcolor{gray}{$\infty$} \\
				      \hline
			      \end{tabular} \quad \textcolor{blue}{$\boxed{p_0=5, p_1=4, p_2=3, p_3 =1}$}
			      \onslide<3->\ncbar[angleA=180]{->}{D}{A}
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Résolution}
		\begin{enumerate}
			\addtocounter{enumi}{2}
			\item Cette méthode correspond au programme suivant :
			      {\inputpartPython{/home/fenarius/Travail/Cours/cpge-info/docs/itc/files/C2/rm.py}{}{\footnotesize}{15}{26}}
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Résolution}
		Remarque : sur cet exemple, les appels récursifs depuis $m(7,0)$ ne construisent pas la totalité de la matrice des valeurs de $m(S,k)$. En effet, le calcul de $m(7,0)$ se fait à partir de celui de $m(7,1)$ et de $m(7-p_0,0)$ et ainsi de suite en remontant dans la matrice : \\
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			\backslashbox{$S$}{$k$} & $0$                                             & $1$                                             & $2$                 & $3$                 & $4$                        \\
			\hline
			$0$                     & \textcolor{gray}{0}                             & \textcolor{gray}{0}                             & \textcolor{gray}{0} & \textcolor{gray}{0} & \textcolor{gray}{$\infty$} \\
			$1$                     &                                                 &                                                 &                    &   \leavevmode\onslide<7->{\textcolor{BrickRed}{\faCheck}}                   & \textcolor{gray}{$\infty$} \\
			$2$                     & \leavevmode\onslide<2->{\textcolor{BrickRed}{\faCheck}} &  \leavevmode\onslide<3->{\textcolor{BrickRed}{\faCheck}}      & \leavevmode\onslide<4->{\textcolor{BrickRed}{\faCheck}}                    &  \leavevmode\onslide<5->{\textcolor{BrickRed}{\faCheck}}                   & \textcolor{gray}{$\infty$} \\
			$3$                     &                                                 &    \leavevmode\onslide<3->{\textcolor{BrickRed}{\faCheck}}                                             &   \leavevmode\onslide<4->{\textcolor{BrickRed}{\faCheck}}                  &  \leavevmode\onslide<5->{\textcolor{BrickRed}{\faCheck}}                   & \textcolor{gray}{$\infty$} \\
			$4$                     &                                                 &                                                 &   \leavevmode\onslide<4->{\textcolor{BrickRed}{\faCheck}}                  &  \leavevmode\onslide<5->{\textcolor{BrickRed}{\faCheck}}                   & \textcolor{gray}{$\infty$} \\
			$5$                     &                                                 &                                                 &                     &     \leavevmode\onslide<5->{\textcolor{BrickRed}{\faCheck}}                 & \textcolor{gray}{$\infty$} \\
			$6$                     &                                                 &                                                 &                     & \leavevmode\onslide<6->{\textcolor{BrickRed}{\faCheck}}                    & \textcolor{gray}{$\infty$} \\
			$7$                     & \textcolor{BrickRed}{\faCheck}                          & \leavevmode\onslide<2->{\textcolor{BrickRed}{\faCheck}} &     \leavevmode\onslide<3->{\textcolor{BrickRed}{\faCheck}}                &   \leavevmode\onslide<4->{\textcolor{BrickRed}{\faCheck}}                  & \textcolor{gray}{$\infty$} \\
			\hline
		\end{tabular} \quad \textcolor{blue}{$\boxed{p_0=5, p_1=4, p_2=3, p_3 =1}$}
	\end{exampleblock}
\end{frame}



\end{document}