\PassOptionsToPackage{dvipsnames,table}{xcolor}
\documentclass[10pt]{beamer}
\usepackage{Cours}

\begin{document}

\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/MacrosCours.tex}}

% Numéro et titre de chapitre
\setcounter{numchap}{8}
\newcommand{\Ctitle}{\cnum {Structures de données linéaires}}
\newcommand{\SPATH}{/home/fenarius/Travail/Cours/cpge-info/docs/mp2i/files/C\thenumchap}


\newcommand{\maillon}[3]{
	\begin{tabular}{|p{0.2cm}|p{0.2cm}|}
		\hline
		\rnode{#2}{#1} & \rnode{#3}{\phantom{$e_0$}} \\
		\hline
	\end{tabular}
}

% Définition d'une structure de données
\makess{Généralités}
\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Définition : structure de données}
		\begin{itemize}
			\item<1-> En informatique, une \textcolor{blue}{structure de données} est une façon d'organiser, de gérer et de stocker des données permettant d'accéder et de modifier ces données de façon efficace. \\
				\onslide<2->\textcolor{gray}{\small Les tableaux fixes du C sont un exemple de structure de données.}
			\item<3-> L'\textcolor{blue}{interface} de la structure de données est l'ensemble des opérations accessibles à un utilisateur de la structure de données. \\
				\onslide<4->\textcolor{gray}{\small Par exemple, la notation {\tt []} permet d'accéder à un élément du tableau, pour le lire ou le modifier. Par contre, la taille du tableau ne fait pas partie de l'interface.}\\
			\item<5-> L'\textcolor{blue}{implémentation} de la structure de données est la façon dont elle est représentée et codée en mémoire et n'est pas forcément accessible à l'utilisateur.\\
				\onslide<6>\textcolor{gray}{\small On peut utiliser les listes de OCaml via leur interface sans savoir comment elles sont représentées en mémoire par le langage. }
		\end{itemize}
	\end{alertblock}
\end{frame}


% Interface et implémentation
\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Caractérisation par l'interface}
		\begin{itemize}
			\item<1-> La différence entre \textcolor{blue}{interface} et \textcolor{blue}{implémentation} est fondamentale et doit être bien comprise. En effet une même structure de données peut avoir plusieurs implémentations. L'idée est que l'utilisation de la structure de données  doit se faire indépendamment de son implémentation ce qui permet la séparation des programmes en composants indépendants (modularité).\\
				\textcolor{gray}{On utilise la même interface (les opérations arithmétiques) pour manipuler les entiers du C et de Python mais ils ne sont pas implémentés de la même manière.}
			\item<2-> Lorsqu'on définit un \textit{cahier des charges} pour une structure de données (ensemble des données et opérations possibles), on définit ce qu'on appelle un \textcolor{blue}{type abstrait de données}.  Ainsi, une structure de données peut être vue comme une implémentation d'un type abstrait de données.
			\item<3-> La définition complète d'un type abstrait de données inclus généralement la complexité des opérations de l'interface. \\
				\textcolor{gray}{L'ajout d'un élément en tête d'une liste de OCaml est une opération en $O(1)$.}
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}{\Ctitle}{\stitle}
	\begin{block}{Opérations de l'interface}
		\begin{itemize}
			\item<1-> La création d'une structure de données se fait à l'aide d'une opération de l'interface appelé \textcolor{blue}{constructeur} \\
				\onslide<2->\textcolor{gray}{Par exemple en C, \mintinline{c}{double tab[10];}}
			\item<2-> La récupération d'une valeur dans la structure se fait à l'aide d'\textcolor{blue}{accesseur} (en anglais \textit{getter}).\\
				\onslide<3->\textcolor{gray}{Par exemple en C, \mintinline{c}{double e =  tab[3];}}
			\item<2-> La modification d'une valeur dans la structure se fait à l'aide de \textcolor{blue}{transformateur} (en anglais \textit{setter}).\\
				\onslide<3->\textcolor{gray}{Par exemple en C, \mintinline{c}{tab[3] = 7.5;}\\}
				\onslide<4->{\textcolor{BrickRed}{\small \danger} On distingue les structures de données mutables (comme les tableaux du C) des structures de données immuables (comme les listes de OCaml). En cas de non mutabilité, pour modifier une structure de données on doit en construire une nouvelle.}
		\end{itemize}
	\end{block}
\end{frame}

% Tableaux 
\makess{Tableaux}
\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Définition}
		\begin{itemize}
			\item un tableau est une séquence de $n$ valeurs de même type \textcolor{blue}{consécutives en mémoire}. \\
			      \begin{tabularx}{0.9\textwidth}{|Y|Y|Y|Y|Y|Y|}
				      \hline
				      {\tt tab[0]}                              & {\tt tab[1]}         & \dots                                     & {\tt tab[i]}         & \dots & {\tt tab[n-1]} \\
				      \hline
				      \multicolumn{1}{c}{$\uparrow$}            & \multicolumn{2}{c}{} & \multicolumn{1}{c}{$\uparrow$}            & \multicolumn{2}{c}{}                          \\
				      \multicolumn{1}{c}{\rnode{a0}{\tt adr 0}} & \multicolumn{2}{c}{} & \multicolumn{1}{c}{\rnode{ai}{\tt adr i}} & \multicolumn{2}{c}{}                          \\
			      \end{tabularx} \\
			\item<2-> L'accès à un élément se fait \textcolor{blue}{temps constant}, en effet il suffit  de connaitre la taille \textcolor{OliveGreen}{\tt t} d'une case et de disposer de l'adresse du premier élément du tableau {\tt adr0}. L'adresse de l'élément d'indice {\tt i} s'obtient alors en ajoutant à l'adresse du premier élément $i$ fois la taille d'une case.
				\onslide<3->{\ncline[linecolor=blue,nodesep=0.1]{->}{a0}{ai} \naput{\tt + i * \textcolor{OliveGreen}{t}}}
			\item<4-> La suppression ou l'insertion d'un élément demande par contre la recopie des éléments et ce sont donc des opérations en $O(n)$.
			\item<5-> Les tableaux de OCaml seront vus au chapitre suivant, on se limite donc pour le moment à l'utilisation de ceux du C.
		\end{itemize}
	\end{alertblock}
\end{frame}

\makess{Liste chainées}
\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Définition}
		\begin{center}
			\rnode{head}{\phantom{Y}}  \quad \maillon{$e_0$}{v0}{p0} \  \maillon{$e_1$}{v1}{p1}  \maillon{$e_2$}{v2}{p2}  \maillon{$e_3$}{v3}{p3}  \maillon{$e_4$}{v4}{p4} \maillon{$e_5$}{v5}{p5} \  \rnode{null}{\raisebox{-2pt}{$\bot$}}
			\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{->}{p0}{v1}
			\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p1}{v2}
			\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p2}{v3}
			\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p3}{v4}
			\ncline[nodesepB=0.25cm,nodesepA=-0.25cm]{*->}{p4}{v5}
			\ncline[nodesepB=0.05cm,nodesepA=-0.25cm]{*->}{p5}{null}
		\end{center}
		\begin{itemize}
			\item<2-> Contrairement aux tableaux, les différentes valeurs ne sont pas stockés de façon contiguës en mémoire.
			\item<3-> Avec chaque élément, on stocke aussi dans un \og{} maillon \fg{} l'emplacement de son successeur. Le successeur du dernier élément se note $\bot$.
			\item<4-> Pour accéder à un élément, on doit parcourir tout ceux qui le précèdent. L'accès à un élément est donc une opération en $O(n)$.
			\item<5-> L'ajout  ou la suppression en tête de liste est en $O(1)$, la taille de la structure de données n'est pas fixé à la construction contrairement aux tableaux.
			\item<6-> Les listes chainées peuvent être définies de façon \textcolor{blue}{récursive} :
				\begin{itemize}
					\item<7-> Une liste est soit vide (référence vers $\bot$)
					\item<8-> Soit c'est la donnée d'un maillon consitué d'une valeur et d'une référence vers une liste.
				\end{itemize}
		\end{itemize}
	\end{alertblock}
\end{frame}

% Liste chainée : implémentation

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Implémentation en C}
		On peut définir un maillon comme un \mintinline{c}{struct} avec les champs {\tt valeur} et pointeur vers un {\tt maillon} :
		\inputpartC{\SPATH/liste_chainee.c}{\small}{}{4}{9}
	\end{block}
	\begin{block}{Implémentation en OCaml}
		\begin{itemize}
			\item Le type {\tt 'a list} est prédéfini dans le langage
			\item Attention, les listes de OCaml ne sont pas mutables
			\item Tous les éléments doivent être du même type
		\end{itemize}
	\end{block}
\end{frame}

% Piles : approche sémantique
\makess{Piles}
\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Piles}
		\begin{itemize}
			\item<1-> Au niveau sémantique, une \textcolor{blue}{pile} est semblable à une pile d'objet dans la vie de tous les jours.
				\onslide<2->{\begin{center}
					\hspace{-2.5cm} \onslide<6->{\rnode{emp}{\framebox[1cm]{\tt elt}}} \qquad \qquad \qquad \qquad \qquad \onslide<9->{\rnode{dep}{\framebox[1cm]{\tt elt}}} \\
					\begin{tabular}{|p{1cm}|c}
						\cline{1-1}
						\rnode{sommet}{\tt elt4} & \onslide<4->{$\leftarrow$ \textcolor{blue}{sommet}} \\
						\cline{1-1}
						{\tt elt3}               &                                                     \\
						\cline{1-1}
						{\tt elt2}               &                                                     \\
						\cline{1-1}
						{\tt elt1}               &                                                     \\
						\cline{1-1}
					\end{tabular}}
					\onslide<6->{\ncangle[angleB=90, armB=0,offsetB=-0.1cm,linestyle=dashed]{->}{emp}{sommet}}
					\onslide<7->{\rput(-4.2,1.4){{\footnotesize \textcolor{blue}{empiler}}}}
					\onslide<9->{\ncangle[angleB=90, armB=0,nodesepA=-1cm,linestyle=dashed]{<-}{dep}{sommet}}
					\onslide<10->{\rput(-1.8,1.4){{\footnotesize \textcolor{blue}{dépiler}}}}
				\end{center}
				\item<3->{L'élément situé en haut de la pile s'appelle le \textcolor{blue}{sommet}.}
			\item<5-> Empiler signifie ajouter un élément au sommet de la pile
			\item<8-> Dépiler signifie retirer l'élément situé au sommet de la pile
			\item<11-> Ainsi le premier élément entré dans la pile sera aussi le dernier à en sortir, on dit qu'une pile est une structure \textcolor{blue}{\sc lifo} \textit{Last In First Out}
		\end{itemize}
	\end{alertblock}
\end{frame}


% Piles
\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Piles comme structures de données}
		L'interface d'une structure de données Pile se limite donc aux opérations suivantes :
		\begin{itemize}
			\item<2-> \textcolor{blue}{\tt est\_vide()} qui renvoie un booléen indiquant si la pile est vide ou non.
			\item<3-> \textcolor{blue}{\tt empiler()} (en anglais \textit{push}) qui ajoute un élément au sommet de la pile.
			\item<4-> \textcolor{blue}{\tt depiler()} (en anglais \textit{pop}) qui retire l'élément situé au sommet (cela n'est possible que si la pile n'est pas vide).
		\end{itemize}
	\end{alertblock}
	\onslide<5->{
		\begin{block}{Utilisation}
			En dépit de sa simplicité, cette structure de données a de nombreuses applications en informatique : pile d'appel récursif, pile d'évaluation d'une expression, \dots
		\end{block}}
\end{frame}

% Piles : EX1
\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Manipulation de piles}
		\begin{itemize}
			\item<2-> On considère la pile : {\tt P = |"A","L","I","X">} (le sommet est {\tt "X"}). Quelle suite d'opération permet d'obtenir {\tt P=|"A","L","E","X">} ?
			\item<3-> Un programmeur décide d'utiliser une pile afin de stocker une réponse entrée au clavier. Chaque caractère tapé doit être empiler. Traduire en terme d'opérations sur cette pile les actions suivantes :
				\begin{enumerate}
					\item<4-> Appuie sur la touche "o"
					\item<5-> Appuie sur la touche "i"
					\item<6-> Appuie sur la touche \framebox{$\longleftarrow$} (\textit{backspace})
					\item<7-> Appuie sur la touche "k"
				\end{enumerate}
		\end{itemize}
	\end{exampleblock}
\end{frame}

% Piles : EX2
\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Manipulation de piles}
		Au jeu des tours des Hanoï, on gère les trois tours {\tt T1, T2 et T3} à l'aide de trois piles.
		\begin{enumerate}
			\item<2-> Quel est le contenu de chacune des piles dans la situation ci-dessous ? (un disque est réprésenté dans la pile par sa taille)
				\begin{center}
					\includegraphics[scale=0.14]{hanoi_dep.eps}
				\end{center}
			\item<3-> Ecrire les opérations permettant de passer la situation précédente à celle ci-dessous :
				\begin{center}
					\includegraphics[scale=0.18]{hanoi_fin.eps}
				\end{center}
		\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Implémentation des piles}
		Plusieurs implémentations sont possibles :
		\begin{itemize}
			\item<1-> A l'aide d'une liste chainée, le début de la liste représente alors le sommet. 
			\item<2-> Si la capacité de la pile est bornée et connue en amont, on peut aussi utiliser un tableau et mémoriser la taille {\tt t} de la pile. Puis,
			\begin{itemize}
				\item<3-> pour tester si la pile est vide on teste si {\tt t} est égal à 0,
				\item<4-> pour empiler une valeur {\tt v}, on affecte {\tt tab[t]=v} et on incrémente {\tt t},
				\item<5-> pour dépiler renvoie {\tt tab[t]} et décrémente {\tt t}.
			\end{itemize}
		\end{itemize}
	\end{block}
\end{frame}

% Files : approche sémantique
\makess{Files}
\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Files}
		\begin{itemize}
			\item<1-> Au niveau sémantique, une \textcolor{blue}{file} est semblable à une file d'attente dans la vie de tous les jours.
				\onslide<2->{\begin{center}
					\onslide<4->{\rnode{enf}{\framebox[1cm]{\tt elt}}}  \hspace{1cm}
					\begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
						\hline
						\rnode{in}{\tt elt4} & {\tt elt3} & {\tt elt2} & \rnode{out}{\tt elt1} \\
						\hline
					\end{tabular}
					\hspace{1cm} \onslide<9->{\rnode{def}{\framebox[1cm]{\tt elt}}}
					}
					\onslide<5->{\ncline[linestyle=dashed,nodesepB=0.2cm]{->}{enf}{in}}
					\onslide<6->{\naput{{\footnotesize \textcolor{blue}{enfiler}}}}
					\onslide<9->{\ncline[linestyle=dashed,nodesepA=0.4cm]{->}{out}{def}}
					\onslide<10->{\naput{{\footnotesize \textcolor{blue}{défiler}}}}
				\end{center}
			\item<3-> Enfiler signifie ajouter un élément en fin de file
			\item<7-> Défiler signifie retirer l'élément situé au début de la file.
			\item<11-> Ainsi le premier élément entré dans la file sera aussi le premier à en sortir, on dit qu'une file est une structure \textcolor{blue}{\sc fifo} \textit{First In First Out}
		\end{itemize}
	\end{alertblock}
\end{frame}



% Files
\begin{frame}{\Ctitle}{\stitle}
	\begin{alertblock}{Files comme structures de données}
		L'interface d'une structure de données File se limite donc aux opérations suivantes :
		\begin{itemize}
			\item<2-> \textcolor{blue}{\tt est\_vide()} qui renvoie un booléen indiquant si la file est vide ou non.
			\item<3-> \textcolor{blue}{\tt enfiler(element)} qui ajoute un élément à la fin de la file.
			\item<4-> \textcolor{blue}{\tt defiler()} qui retire l'élément situé au début de la file (cela n'est possible que si la file n'est pas vide).
		\end{itemize}
	\end{alertblock}
	\onslide<5->{
		\begin{block}{Utilisation}
			Comme pour les piles, cette structure de données a de nombreuses applications en informatique : file d'attente d'une imprimante, simulation de files d'attentes réelles, \dots
		\end{block}}
\end{frame}

% Piles : EX1
\begin{frame}{\Ctitle}{\stitle}
	\begin{exampleblock}{Manipulation de files}
		\begin{itemize}
			\item<2-> On considère la file : {\tt F = >"E","L","S","A">}. Quelle suite d'opération permet d'obtenir {\tt F= >"N","O","E","L">} ?
			\item<3-> On simule la file d'attente d'une imprimante à l'aide d'une file. A quelle opération sur cette file correspond l'envoie d'une nouvelle impression ? La fin de l'impression en cours ? Dans quel ordre seront effectuées les impressions ?
		\end{itemize}
	\end{exampleblock}
\end{frame}


\begin{frame}[fragile]{\Ctitle}{\stitle}
	\begin{block}{Implémentation des files}
		Plusieurs implémentations sont possibles :
		\begin{itemize}
			\item<1-> A l'aide d'une liste chainée, dans ce cas si on veut pouvoir enfiler et défiler en temps constant, il faut disposer d'un accès au premier maillon et au dernier maillon. 
			\item<2-> Si la capacité de la file est bornée et connue en amont, on peut aussi utiliser un tableau de façon circulaire en mémorisant l'indice du début de la file et l'indice de fin.
			\item<3-> On peut aussi implémenter une file avec deux piles. 
		\end{itemize}
	\end{block}
\end{frame}

\end{document}