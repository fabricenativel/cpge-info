\PassOptionsToPackage{dvipsnames,table}{xcolor}
\documentclass[11pt,a4paper]{article}

\usepackage{DS}

\begin{document}

\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/Macros.tex}}
\ModeExercice
\DS{PCSI}{2}{Mars 2025}

\setboolean{corrige}{false}


\alertbox{\danger}{Consignes}{
	\begin{itemize}
		\item[\textbullet] La calculatrice n'est \textbf{pas autorisée}.
		\item[\textbullet] On pourra toujours librement utiliser une fonction demandée à une question précédente même si cette question n'a pas été traitée.
		\item[\textbullet] Veillez à présenter vos idées et vos réponses partielles même si vous ne trouvez pas la solution complète à une question.
		\item[\textbullet] La clarté et la lisibilité de la rédaction et des programmes sont des éléments de notation.
	\end{itemize}
}

\begin{Exercise}[title={Questions de cours}]
	\Question{Sur la récursivité}
	\subQuestion{Donner la définition d'une fonction récursive.}
    \tcor{Une fonction récursive est une fonction qui s'appelle elle-même.}
	\subQuestion{Quel serait le comportement d'une fonction récursive dépourvue de condition d'arrêt ?}
    \tcor{En l'absence de condition d'arrêt la fonction s'appelle elle-même à l'infini et donc ne s'arrête jamais.}
	\subQuestion{Ecrire une fonction \textit{iterative} {\tt occurrences} qui prend en argument une chaine de caractères {\tt s} et un caractère {\tt c} et qui renvoie le nombre d'apparitions du caractère {\tt c} dans la chaine {\tt s}. Par exemples, {\tt occurrences("un exemple",'e')} renvoie {\tt 3} et {\tt occurrences("un exemple",'a')}} renvoie {\tt 0}. 
    \ifcorrige
    \inputpartPython{occ.py}{}{}{1}{7}
    \fi
	\subQuestion{Ecrire une version \textit{récursive} de cette fonction. \\
	{\small \aide \;} Indication : on rappelle que si {\tt s} une chaine de caractères alors {\tt s[1:]} est la chaine {\tt s} privée de son premier caractère. Par exemple {\tt "Python"[1:]} est la chaine {\tt "ython"}.
	}
    \ifcorrige
    \inputpartPython{occ.py}{}{}{10}{17}
    \fi
	\Question{Sur le tri par sélection}
	\subQuestion{Expliquer brièvement le principe de l'algorithme du \textit{tri par sélection} et donner l'évolution du contenu de la liste \mintinline{python}{[42, 28, 11, 9, 33]}  lorsqu'elle est triée en utilisant cet algorithme.}
    \tcor{On parcourt la liste avec un indice {\tt i} à partir du début. Pour chaque valeur de {\tt i} on sélectionne l'indice {\tt m} du minimum des éléments de la liste \textit{à partir} de l'indice {\tt i} et on l'échange avec celui d'indice {\tt i}. Sur la liste \mintinline{python}{[42, 28, 11, 9, 33]}, on obtient successivement :
    \begin{itemize}
    \item \mintinline{python}{[9, 28, 11, 42, 33]}
    \item \mintinline{python}{[9, 11, 28, 42, 33]}
    \item \mintinline{python}{[9, 11, 28, 42, 33]}
    \item \mintinline{python}{[9, 11, 28, 33, 42]}
    \end{itemize}
    }
	\subQuestion{Ecrire en Python une fonction {\tt echange} qui prend en argument une liste {\tt lst} ainsi que deux entiers {\tt i} et {\tt j} ne renvoie rien et échange les éléments d'indice {\tt i} et {\tt j} de cette liste. Par exemple, si {\tt lst = [25, 17, 34, 22, 37]} alors {\tt echange(lst, 1, 3)} doit modifier la liste {\tt lst} en {\tt [25, 22, 34, 17, 37]}. On vérifiera les préconditions sur {\tt i} et {\tt j} à l'aide d'instructions {\tt assert}.}
    \ifcorrige
    \inputpartPython{tri_selection.py}{}{}{3}{6}
    \fi
	\subQuestion{Ecrire en Python une fonction {\tt indice\_min\_depuis} qui prend en argument une liste {\tt lst} et un entier {\tt i} et renvoie l'indice du plus petit élément de la liste {\tt lst} à partir de l'indice {\tt i}. Par exemple, si {\tt lst = [25, 17, 34, 22, 37]} alors {\tt indice\_min\_depuis(lst, 2)} doit renvoyer {\tt 3} (c'est à dire l'indice de {\tt 22} qui est l'élément minimal à partir de celui d'indice 2).}
    \ifcorrige
    \inputpartPython{tri_selection.py}{}{}{8}{14}
    \fi
	\subQuestion{Ecrire en Python une fonction {\tt tri\_selection} qui prend en argument une liste {\tt lst} et modifie cette liste de façon à la trier par ordre croissant en utilisant l'algorithme du tri par sélection. On utilisera les fonctions {\tt echange} et {\tt indice\_min\_depuis} écrites aux questions précédentes.}
    \ifcorrige
    \inputpartPython{tri_selection.py}{}{}{16}{20}
    \fi
	\subQuestion{Un ordinateur a pris 3 secondes pour trier une liste de \numprint{250000} éléments en utilisant un tri par sélection. Donner une estimation (aucune justification n'est demandée) du temps que prendrait cet ordinateur pour trier une liste de \numprint{1000000} éléments en utilisant le même algorithme.}
    \ifcorrige
    \tcor{On peut estimer que le temps de calcul est proportionnel au carré du nombre d'éléments à trier. Ainsi, si le temps est de 3 secondes pour \numprint{250000} éléments, il serait de $3 \times \left(\frac{1000000}{250000}\right)^2 = 3 \times 16 = 48$ secondes pour \numprint{1000000} éléments. La justification n'était pas demandée mais en examinant l'algorithme on peut constater que le nombre d'opérations à effectuer évolue comme le carré du nombre d'éléments à trier.}
    \fi
	\Question{Sur la représentation binaire des entiers}
	\subQuestion{Donner l'écriture en base 2 de $(172)_{10}$.}
    \tcor{$(172)_{10} = (10101100)_2$}
	\subQuestion{Ecrire $(10011101)_2$ en base 10.}
    \tcor{C'est $(10011101)_2 = 1 \times 2^7 + 0 \times 2^6 + 0 \times 2^5 + 1 \times 2^4 + 1 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 128 + 16 + 8 + 4 + 1 = 157$}
	\subQuestion{Quel est le plus grand nombre représentable en base 2 en utilisant 10 bits ?}
    \tcor{Le plus grand nombre représentable en base 2 avec 10 bits est $(1111111111)_2 = 2^{10} - 1 = 1023$}
	\subQuestion{On suppose que l'on travaille sur des entiers codés sur 8 bits en complément à 2. A quel nombre entier en base 10 correspond $(11011001)_2$ ?}
    \tcor{Le bit de poids fort est compté négativement et les autres positivement. Donc $(11011001)_2 = -2^7 + 2^6 + 2^4 + 2^3 + 2^0 = -128 + 64 + 16 + 8 + 1 = -39$}
\end{Exercise}

\begin{Exercise}[title = {Permutation des éléments d'une liste}]
	\Question{Le but de cette partie est de dénérer \textit{une} permutation aléatoire des éléments d'une liste}\\
	Le \textit{mélange de Fischer-Yates} (aussi appelé \textit{mélange de Knuth}) est un algorithme de mélange aléatoire des éléments d'une liste. Il consiste à parcourir la liste en partant de la fin avec un indice {\tt i} et à échanger l'élément d'indice {\tt i} avec un élément choisi aléatoirement parmi les éléments ayant un indice inférieur \textit{ou égal}.
	Voici un exemple du déroulement de l'algorithme (crédit : Wikipedia) sur la liste {\tt ['E','L','V','I','S]} on part de la fin (donc de l'indice 4) : \\
	\begin{tabular}{|l|l|l|l|}
		\hline
		Etat de la liste                        & Indice {\tt i} & Choix aléatoire dans $\intN{0}{i}$ & Liste après échange         \\
		\hline
		{\tt ['E','L','V','I',\underline{'S'}]} & 4              & 4                                  & {\tt ['E','L','V','I','S']} \\
		{\tt ['E','L','V',\underline{'I'},'S']} & 3              & 0                                  & {\tt ['I','L','V','E','S']} \\
		{\tt ['I','L',\underline{'V'},'E','S']} & 2              & 2                                  & {\tt ['I','L','V','E','S']} \\
		{\tt ['I',\underline{'L'},'V','E','S']} & 1              & 0                                  & {\tt ['L','I','V','E','S']} \\
		\hline
	\end{tabular}
	\subQuestion{Donner le déroulement de l'algorithme sur la liste {\tt ['A','B','C','D','E','F']} en supposant que les choix aléatoires successifs sont : {\tt 2, 0, 3, 1, 0}.}
    \tcor{On obtient les évolutions suivantes de la liste :
    \begin{itemize}
    \item {\tt ['A','B','F','D','E','C']} (élément d'indice 5 :{\tt 'F'} échangé avec celui d'indice 2 : {\tt 'C'})
    \item {\tt ['E','B','F','D','A','C']} (élément d'indice 4  échangé avec celui d'indice 0)
    \item {\tt ['E','B','F','D','A','C']} (élément d'indice  3 échangé avec celui d'indice 3)
    \item {\tt ['E','F','B','D','A','C']} (élément d'indice  2 échangé avec celui d'indice 1)
    \item {\tt ['F','E','B','D','A','C']} (élément d'indice  1 échangé avec celui d'indice 0)
    \end{itemize}
    
    }
	\subQuestion{Afin de générer une entier aléatoire on veut utiliser la fonction {\tt randint} du module {\tt math}. Que faut-il écrire en début de programme pour que cette fonction soit utilisable ?}
    \ifcorrige
    \inputpartPython{melange.py}{}{}{1}{1}
    \fi
	\subQuestion{Ecrire en Python une fonction \textit{itérative}, {\tt melange\_iteratif} qui prend en argument une liste {\tt lst} ne renvoie rien et mélange aléatoirement les éléments de la liste en utilisant l'algorithme de Fischer-Yates. On supposera déjà écrite une fonction {\tt echange} qui prend en argument une liste ainsi que deux indices et échange les éléments situés à ces indices.}
    \ifcorrige
    \inputpartPython{melange.py}{}{}{7}{10}
    \fi
	\subQuestion{Ecrire en Python une fonction \textit{récursive},
		{\tt melange\_recursif} qui prend en argument une liste {\tt lst} ne renvoie rien et mélange aléatoirement les éléments de la liste en utilisant l'algorithme de Fischer-Yates.\\
         {\small \aide \;} Indication : on pourra fournir à cette fonction un paramètre entier {\tt i} indiquant l'indice de l'élément qui sera potentiellement échangé avec l'un de ceux qui le précède.}
    \ifcorrige
    \inputpartPython{melange.py}{}{}{12}{16}
    \fi
	\Question{Le but de cette partie est de générer la liste de \textit{toutes} les permutations d'une liste.}\\
	On souhaite écrire une fonction {\tt permutation} qui prend en argument une liste et renvoie la liste de toutes les permutations de cette liste. Par exemple {\tt \small permutation(['I','T','C'])} doit renvoyer la liste : \\
	{\tt \small [['I','T','C'], ['I','C','T'], ['T','I','C'], ['T','C','I'], ['C','T','I'], ['C','I','T']]}. \\
	Pour cela on propose l'algorithme \textit{récursif} suivant : on commence par générer la permutation de la sous liste commençant à l'indice 1 puis on insère le premier élément à toutes les positions possibles dans les listes obtenues. Sur l'exemple de la liste {\tt ['I','T','C']}, on génère donc les permutations de {\tt ['T','C']} c'est à dire {\tt [['T','C'], ['C','T']]}. Puis on insère {\tt 'I'} à toutes les positions possibles dans ces listes ce qui donne : \\
	{\tt \small [['I','T','C'], ['T','I','C'], ['T','C','I'], ['I','C','T'], ['C','I','T'], ['C','T','I']]}.
	\Question{Ecrire la fonction {\tt insere} qui prend en argument un élément {\tt elt} une liste {\tt lst} et renvoie la liste de listes obtenues en insérant {\tt elt} à toutes les positions possibles dans {\tt lst}. Par exemple, si {\tt lst = ['T','C']} et {\tt elt = 'I'} alors {\tt insere(elt, lst)} doit renvoyer {\tt [['I','T','C'], ['T','I','C'], ['T','C','I']]}.}
	\Question{Ecrire en Python une fonction \textit{récursive}, {\tt permutation} qui prend en argument une liste {\tt lst} et renvoie la liste des permutations de la liste {\tt lst}.\\
    {\small \aide \;} Indication : on pourra générer \textit{récursivement} les permutations de {\tt lst} privé de son premier élément puis insérer cet élément à tous les emplacements possibles grâce à la fonction précédente.     
    }
\end{Exercise}


\begin{Exercise}[title={Problème du sac à dos}]\\
	On dispose d'un sac à dos pouvant contenir un poids maximal noté $P$ et de $n$ objets ayant chacun un poids $\left(p_i\right)_{0\leqslant i \leqslant n-1}$ et une valeur $\left(v_i\right)_{0\leqslant i \leqslant n-1}$. On cherche à remplir le sac à dos de manière à maximiser la valeur totale des objets contenus dans le sac sans dépasser le poids maximal $P$.
	Par exemple, si on dispose des objets suivants :
	\begin{itemize}
		\item un objet de poids $p_0 = 4$ et de valeur $v_0 = 20$,
		\item un objet de poids $p_1 = 5$ et de valeur $v_1 = 28$,
		\item un objet de poids $p_2 = 6$ et de valeur $v_2 = 36$,
		\item un objet de poids $p_3 = 7$ et de valeur $v_3 = 50$,
	\end{itemize}
	et qu'on suppose que le poids maximal du sac est $10$ alors un choix possible serait de prendre l'objet 3, aucun autre objet ne rentre alors dans le sac et la valeur du sac est  de $50$ avec un poids de 7. Une autre possibilité plus intéressante serait de choisir les objets 0  et 2, la valeur totale serait alors de $56$ et le poids du sac de $10$.\smallskip

	Dans toute la suite de l'exercice on supposera que les poids et les valeurs des objets sont fournis sous la forme d'une liste de Python contenant les tuples {\tt (poids, valeur)} représentant les objets. Par exemple, les objets précédents seraient représentés par la liste suivante :
	\begin{minted}{python}
objets = [(4, 20), (5, 28), (6, 36), (7, 50)]
\end{minted}
	\Question{On considère la stratégie gloutonne suivante : on trie les objets par ordre décroissant de leur rapport valeur/poids et on les prend dans cet ordre jusqu'à ce que le poids maximal soit atteint.}
	\subQuestion{Vérifier qu'en appliquant cette stratégie à la liste d'objets :
		\begin{minted}{python}
[(4, 30), (5, 34), (6, 36), (7, 49), (10, 74)]
\end{minted}
		et un poids maximal de 10, on n'obtient pas la meilleure solution.}
	\tcor{En triant les objets par rapport poids/valeur, on obtient l'ordre suivant :
		\begin{itemize}
			\item objet 0 (poids : 4, valeur : 30, rapport : 7.5)
			\item objet 4 (poids : 10, valeur : 74, rapport : 7.4)
			\item objet 3 (poids : 7, valeur : 49, rapport : 7.0)
			\item objet 1 (poids : 5, valeur : 34, rapport : 6.8)
			\item objet 2 (poids : 6, valeur : 36, rapport : 6.0)
		\end{itemize}
		On parcourt donc cette liste en prenant les objets tant qu'ils ne dépassent pas la contrainte de poids. Cela conduit à choisir les objets 0 et 1 pour une valeur de 64. Cette combinaison n'est pas optimale puisque l'on peut obtenir une valeur de 74 en prenant uniquement l'objet 4.}
	\subQuestion{Ecrire une fonction {\tt glouton}, qui prend en arguments une liste d'objets qu'on suppose \textit{déjà triée par ordre décroissant du rapport valeur/poids} et un poids maximal et qui renvoie la valeur maximale que l'on peut obtenir en appliquant la stratégie gloutonne.}
	\ifcorrige
		\corpartPython{sac.py}{}{}{12}{20}
	\fi
    \subQuestion{Montrer sur un exemple de votre choix (avec au moins 3 objets) que si on choisit de trier les objets par ordre croissant de poids (c'est à dire qu'on choisit en premier les objets les plus légers), alors la stratégie gloutonne ne donne pas non plus la solution optimale.}
    \tcor{On peut par exemple considérer les objets suivants :
    {\tt [(1, 10), (3, 20), (5, 40)]} et un poids maximal de 5. La stratégie gloutonne choisirait les objets 0 et 1 pour une valeur de 30 alors que la solution optimale est de prendre l'objet 2 pour une valeur de 40.}
	\Question{La recherche exhaustive consiste à énumérer tous les choix possibles d'objet et à calculer la valeur ainsi que le poids pour chaque choix, on retient alors le choix qui maximise la valeur du sac sans dépasser le poids maximal. On propose de représenter un choix d'objets par une liste contenant des 0 et des 1. Si le $i$-ème élément de la liste vaut $1$ alors l'objet $i$ est choisi, s'il vaut $0$ alors l'objet $i$ n'est pas choisi. Par exemple, pour les objets précédents, le choix de prendre uniquement l'objet 3 serait représenté par la liste \mintinline{python}{[0, 0, 0, 1]} et le choix de prendre les objets 0 et 2 serait représenté par la liste \mintinline{python}{[1, 0, 1, 0]}.}
	\subQuestion{Justifier rapidement que le nombre possible de choix d'objet est $2^n$.}
	\tcor{Pour chaque objet, on a deux choix possibles, le prendre ou non, comme il y a $n$ objets, le nombre total de choix est $2^n$.}


	\subQuestion{Afin de générer tous les choix possibles on propose de parcourir les entiers de $0$ à $2^n - 1$ et de convertir chaque entier en son écriture binaire. Ecrire une fonction {\tt choix} qui prend en argument un entier {\tt n} et un entier {\tt k} tel que $0 \leqslant k \leqslant 2^n -1$ et renvoie la liste des chiffres de $k$ en base 2 sur $n$ bits. Par exemples {\tt choix(8,17) renvoie {\tt [0,0,0,1,0,0,0,1]}} (car on utilise {\tt 8} bits et $(00010001)_2=17$), et {\tt choix(8,121) renvoie {\tt [0,1, 1, 1, 1, 0, 0, 1]}}\\
    {\small \aide \;} Indication : on pourra utiliser la fonction {\tt bin} de Python qui prend en argument un nombre entier et renvoie son écriture en base 2 précédée de {\tt 0b} sous la forme d'une chaine de caractère, par exemple {\tt bin(17)} renvoie {\tt "0b10001"}.}
    \subQuestion{Ecrire une fonction {\tt valeur\_poids} qui prend en arguments, une liste d'objets ainsi qu'un choix d'objet (sous la forme indiquée ci-dessus) et qui renvoie le poids et la valeur du sac correspondant à ce choix. Par exemple avec la liste {\tt objets} donnée en exemple plus haut,  {\tt valeur\_poids(objets, [1, 0, 1, 0])} doit renvoyer $(56, 10)$.}
	\ifcorrige
		\corpartPython{sac.py}{}{}{1}{9}
	\fi
    \subQuestion{Ecrire une fonction {\tt recherche\_exhaustive} qui prend en argument une liste d'objets et un poids maximal et qui renvoie la valeur maximale que l'on peut obtenir en appliquant la stratégie de recherche exhaustive. C'est à dire en testant tous les choix possibles d'objets et en retenant le choix de valeur maximale qui ne dépasse pas le poids maximal autorisé.}
    \ifcorrige
		\corpartPython{sac.py}{}{}{30}{38}
	\fi
\end{Exercise}

\end{document}