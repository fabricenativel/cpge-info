\documentclass[11pt,a4paper]{article}

\usepackage{Act}

\begin{document}
\input{\detokenize{/home/fenarius/Travail/Cours/cpge-info/latex/Macros.tex}}
\ModeExercice
\TD{8}{Structure de données linéaires}

\setcounter{Exercise}{0}

\begin{Exercise}[title = {complexité des opérations}]\\
    On considère les structures de données suivantes :
    \begin{itemize}
        \item Un tableau de taille fixe
        \item Une pile implémentée à l'aide d'une liste simplement chainée
        \item Une file implémentée à l'aide d'une liste simplement chainée ayant un accès sur son dernier élément
    \end{itemize}
    Donner la complexité des opérations suivantes sur chacune de ces structures de données :
    \Question{Accès au n-ième élément}
    \Question{Insertion d'un élément au début (au sommet pour la pile)}
    \Question{Insertion à la fin (tout en bas pour la pile)}
    \Question{Suppression du premier élément}
    \Question{Suppression du dernier élément}
    \Question{Test d'appartenance d'un élément}
\end{Exercise}


\begin{Exercise}[title={Inversion au sommet}]\\
    On suppose qu'on dispose d'une structure de données de type pile dotée de son interface habituelle c'est-à-dire {\tt empiler}, {\tt dépiler} et {\tt est\_vide}.
    Proposer une suite d'opérations permettant d'inverser, lorsqu'ils existent, les deux éléments situés au sommet de cette pile.
    Si la pile contient moins de deux éléments, elle doit rester en l'état.
\end{Exercise}

\begin{Exercise}[title={Taille d'une file}]\\
    Ecrire une fonction prenant en entrée une file file $F$ et renvoyant sa taille. La file $F$ ne doit pas être détruite mais restituée à son état initial et on ne dispose que de l'interface usuelle d'une file (qu'on rapellera).
\end{Exercise}


\begin{Exercise}[title={list de OCaml}]
\Question{Rappeler la complexité de l'opérateur {\tt ::} en OCaml. Expliquer cette complexité}
\Question{Même question pour {\tt @}}
\Question{On considère deux listes en OCaml : {\tt l1=[2; 4; 8]} et {\tt l2=[2; 3; 5; 7]}. Réprésenter en mémoire la liste {\tt l} obtenue à l'aide de \mintinline{ocaml}{let l = l1@l2;;}}
\end{Exercise}

\begin{Exercise}[title={Un exemple de complexité amortie}]\\
On prend l'exemple de la structure de données implémentant le type de \textit{list} de Python grâce à un tableau dynamique en C (voir TP). On considère une \textit{list} dont la taille initiale est $t_0>0$ et on supposera que la capacité initiale est $c_0=2t_0$. Sur cette structure de données, on souhaite déterminer la complexité amortie de l'opération {\tt append} qui consiste à ajouter un élément en fin de liste, deux cas peuvent se produire :
\begin{itemize}
\item[\textbullet] $c>t$ et donc on peut ajouter un nouvel élément sans redimensionner le tableau.
\item[\textbullet] $c=t$ et on redimensionne le tableau en \textit{doublant} la capacité du tableau afin d'y insérer le nouvel élément
\end{itemize}
Montrer que la complexité amortie de {\tt append} est un $\mathcal{O}(1)$. \\
{\small \aide \;} Indication : on pourra introduire $\Phi(S) = 2t -c$.
\end{Exercise}




\end{document}